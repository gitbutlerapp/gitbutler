<script lang="ts">
	import CardOverlay from '$components/CardOverlay.svelte';
	import CommitAction from '$components/CommitAction.svelte';
	import CommitsAccordion from '$components/CommitsAccordion.svelte';
	import Dropzone from '$components/Dropzone.svelte';
	import LineOverlay from '$components/LineOverlay.svelte';
	import ReduxResult from '$components/ReduxResult.svelte';
	import CommitContextMenu, {
		type CommitMenuContext
	} from '$components/v3/CommitContextMenu.svelte';
	import CommitGoesHere from '$components/v3/CommitGoesHere.svelte';
	import CommitRow from '$components/v3/CommitRow.svelte';
	import KebabButton from '$components/v3/KebabButton.svelte';
	import { hasConflicts, isLocalAndRemoteCommit, isUpstreamCommit } from '$components/v3/lib';
	import BaseBranchService from '$lib/baseBranch/baseBranchService.svelte';
	import {
		AmendCommitWithChangeDzHandler,
		AmendCommitWithHunkDzHandler,
		CommitDropData,
		type DzCommitData,
		SquashCommitDzHandler
	} from '$lib/commits/dropHandler';
	import { draggableCommitV3 } from '$lib/dragging/draggable';
	import {
		ReorderCommitDzFactory,
		ReorderCommitDzHandler
	} from '$lib/dragging/stackingReorderDropzoneManager';
	import { DefaultForgeFactory } from '$lib/forge/forgeFactory.svelte';
	import { IdSelection } from '$lib/selection/idSelection.svelte';
	import { StackService, type SeriesIntegrationStrategy } from '$lib/stacks/stackService.svelte';
	import { combineResults } from '$lib/state/helpers';
	import { UiState } from '$lib/state/uiState.svelte';
	import { TestId } from '$lib/testing/testIds';
	import { inject } from '@gitbutler/shared/context';
	import Button from '@gitbutler/ui/Button.svelte';
	import Modal from '@gitbutler/ui/Modal.svelte';
	import { getTimeAgo } from '@gitbutler/ui/utils/timeAgo';
	import type { Commit } from '$lib/branches/v3';
	import type { CommitStatusType } from '$lib/commits/commit';
	import type { BranchDetails } from '$lib/stacks/stack';

	const integrationStrategies = {
		default: {
			label: 'Integrate upstream',
			style: 'warning',
			kind: 'solid',
			icon: undefined,
			action: () => integrate()
		},
		reset: {
			label: 'Reset to remoteâ€¦',
			style: 'neutral',
			kind: 'outline',
			icon: 'warning-small',
			action: confirmReset
		}
	} as const;

	type IntegrationStrategy = keyof typeof integrationStrategies;

	interface Props {
		active: boolean;
		projectId: string;
		stackId: string;
		branchName: string;
		selectedCommitId?: string;
		lastBranch: boolean;
		branchDetails: BranchDetails;
		stackingReorderDropzoneManager: ReorderCommitDzFactory;

		handleUncommit: (commitId: string, branchName: string) => Promise<void>;
		startEditingCommitMessage: (branchName: string, commitId: string) => void;
		handleEditPatch: (args: {
			commitId: string;
			type: CommitStatusType;
			hasConflicts: boolean;
			isAncestorMostConflicted: boolean;
		}) => void;
	}

	let {
		active,
		projectId,
		stackId,
		branchName,
		branchDetails,
		selectedCommitId,
		lastBranch,
		stackingReorderDropzoneManager,
		handleUncommit,
		startEditingCommitMessage,
		handleEditPatch
	}: Props = $props();

	const [stackService, uiState, forge, baseBranchService] = inject(
		StackService,
		UiState,
		DefaultForgeFactory,
		BaseBranchService,
		IdSelection
	);
	const [integrateUpstreamCommits, upstreamIntegration] = stackService.integrateUpstreamCommits;

	const projectState = $derived(uiState.project(projectId));
	const exclusiveAction = $derived(projectState.exclusiveAction.current);
	const commitAction = $derived(exclusiveAction?.type === 'commit' ? exclusiveAction : undefined);
	const isCommitting = $derived(
		exclusiveAction?.type === 'commit' && exclusiveAction.stackId === stackId
	);
	const stackActive = $derived(stackId === projectState.stackId.current);
	const stackState = $derived(uiState.stack(stackId));
	const selection = $derived(stackState.selection.get());
	const selectedBranchName = $derived(selection.current?.branchName);

	const localAndRemoteCommits = $derived(stackService.commits(projectId, stackId, branchName));
	const upstreamOnlyCommits = $derived(
		stackService.upstreamCommits(projectId, stackId, branchName)
	);

	const baseBranchResponse = $derived(baseBranchService.baseBranch(projectId));
	const base = $derived(baseBranchResponse.current.data);
	const baseSha = $derived(base?.baseSha);

	let confirmResetModal = $state<ReturnType<typeof Modal>>();
	let commitMenuContext = $state<CommitMenuContext>();

	async function integrate(strategy?: SeriesIntegrationStrategy): Promise<void> {
		await integrateUpstreamCommits({
			projectId,
			stackId,
			seriesName: branchName,
			strategy
		});
	}

	function confirmReset() {
		confirmResetModal?.show();
	}

	function getAncestorMostConflicted(commits: Commit[]): Commit | undefined {
		if (!commits.length) return undefined;
		for (let i = commits.length - 1; i >= 0; i--) {
			const commit = commits[i]!;
			if (commit.hasConflicts) {
				return commit;
			}
		}
		return undefined;
	}

	async function handleCommitClick(commitId: string, upstream: boolean) {
		const stackState = uiState.stack(stackId);
		stackState.selection.set({ branchName, commitId, upstream });
		projectState.stackId.set(stackId);
	}
</script>

<Modal
	bind:this={confirmResetModal}
	title="Reset to remote"
	type="warning"
	width="small"
	onSubmit={async (close) => {
		await integrate('hardreset');
		close();
	}}
>
	<p class="text-13 text-body helper-text">
		This will reset the branch to the state of the remote branch. All local changes will be
		overwritten.
	</p>
	{#snippet controls(close)}
		<Button kind="outline" type="reset" onclick={close}>Cancel</Button>
		<Button style="error" type="submit">Reset</Button>
	{/snippet}
</Modal>

{#snippet integrateUpstreamButton(strategy: IntegrationStrategy)}
	{@const { label, icon, style, kind, action } = integrationStrategies[strategy]}
	<Button
		testId={TestId.UpstreamCommitsIntegrateButton}
		{style}
		{kind}
		grow
		{icon}
		reversedDirection
		loading={upstreamIntegration.current.isLoading}
		onclick={action}
	>
		{label}
	</Button>
{/snippet}

{#snippet commitReorderDz(dropzone: ReorderCommitDzHandler)}
	<Dropzone handlers={[dropzone]}>
		{#snippet overlay({ hovered, activated })}
			<LineOverlay {hovered} {activated} />
		{/snippet}
	</Dropzone>
{/snippet}

<ReduxResult
	{stackId}
	{projectId}
	result={combineResults(upstreamOnlyCommits.current, localAndRemoteCommits.current)}
>
	{#snippet children([upstreamOnlyCommits, localAndRemoteCommits], { stackId })}
		{@const hasRemoteCommits = upstreamOnlyCommits.length > 0}
		{@const hasCommits = localAndRemoteCommits.length > 0}
		{@const ancestorMostConflicted = getAncestorMostConflicted(localAndRemoteCommits)}
		{#if !hasCommits && isCommitting}
			<CommitGoesHere
				selected={stackActive &&
					(branchName === commitAction?.branchName ||
						!commitAction?.branchName ||
						!commitAction.parentCommitId)}
				first
				last
				onclick={() => {
					projectState.exclusiveAction.set({
						type: 'commit',
						stackId,
						branchName,
						parentCommitId: branchDetails.baseCommit
					});
				}}
			/>
		{/if}
		<div class="commit-list">
			{#if hasRemoteCommits}
				<CommitsAccordion
					testId={TestId.UpstreamCommitsAccordion}
					count={Math.min(upstreamOnlyCommits.length, 3)}
					isLast={!hasCommits}
					type="upstream"
					displayHeader={upstreamOnlyCommits.length > 1}
				>
					{#snippet title()}
						<span class="text-13 text-body text-semibold">Upstream commits</span>
					{/snippet}

					{#each upstreamOnlyCommits as commit, i (commit.id)}
						{@const first = i === 0}
						{@const lastCommit = i === upstreamOnlyCommits.length - 1}
						{@const selected =
							stackActive && commit.id === selectedCommitId && branchName === selectedBranchName}
						{@const commitId = commit.id}
						{#if !isCommitting}
							<CommitRow
								type="Remote"
								{stackId}
								{commitId}
								commitMessage={commit.message}
								createdAt={commit.createdAt}
								tooltip="Upstream"
								{branchName}
								{first}
								lastCommit={lastCommit && localAndRemoteCommits.length === 0}
								{selected}
								{active}
								onclick={() => handleCommitClick(commit.id, true)}
								disableCommitActions={false}
							/>
						{/if}
					{/each}

					<CommitAction type="Remote" isLast={!hasCommits}>
						{#snippet action()}
							<!-- TODO: Ability to select other actions would be nice -->
							{@render integrateUpstreamButton('default')}
						{/snippet}
					</CommitAction>
				</CommitsAccordion>
			{/if}

			{@render commitReorderDz(stackingReorderDropzoneManager.top(branchName))}
			{#each localAndRemoteCommits as commit, i (commit.id)}
				{@const first = i === 0}
				{@const last = i === localAndRemoteCommits.length - 1}
				{@const commitId = commit.id}
				{@const selected =
					stackActive && commit.id === selectedCommitId && branchName === selectedBranchName}
				{#if isCommitting}
					<!-- Only commits to the base can be `last`, see next `CommitGoesHere`. -->
					<CommitGoesHere
						selected={(commitAction?.parentCommitId === commitId ||
							(first && commitAction?.parentCommitId === undefined)) &&
							commitAction?.branchName === branchName}
						{first}
						last={false}
						onclick={() => {
							projectState.exclusiveAction.set({
								type: 'commit',
								stackId,
								branchName,
								parentCommitId: commitId
							});
						}}
					/>
				{/if}
				{@const dzCommit: DzCommitData = {
					id: commit.id,
					isRemote: isUpstreamCommit(commit),
					isIntegrated: isLocalAndRemoteCommit(commit) && commit.state.type === 'Integrated',
					hasConflicts: isLocalAndRemoteCommit(commit) && commit.hasConflicts,
				}}
				{@const amendHandler = new AmendCommitWithChangeDzHandler(
					projectId,
					stackService,
					stackId,
					branchName,
					dzCommit,
					(newId) => uiState.stack(stackId).selection.set({ branchName, commitId: newId }),
					uiState
				)}
				{@const squashHandler = new SquashCommitDzHandler({
					stackService,
					projectId,
					stackId,
					commit: dzCommit
				})}
				{@const hunkHandler = new AmendCommitWithHunkDzHandler({
					stackService,
					projectId,
					stackId,
					commit: dzCommit,
					// TODO: Use correct value!
					okWithForce: true,
					uiState
				})}
				{@const tooltip = commit.state.type}
				<Dropzone handlers={[amendHandler, squashHandler, hunkHandler]}>
					{#snippet overlay({ hovered, activated, handler })}
						{@const label =
							handler instanceof AmendCommitWithChangeDzHandler ||
							handler instanceof AmendCommitWithHunkDzHandler
								? 'Amend'
								: 'Squash'}
						<CardOverlay {hovered} {activated} {label} />
					{/snippet}
					<div
						use:draggableCommitV3={{
							disabled: false,
							label: commit.message.split('\n')[0],
							sha: commit.id.slice(0, 7),
							date: getTimeAgo(commit.createdAt),
							authorImgUrl: undefined,
							commitType: commit.state.type,
							data: new CommitDropData(
								stackId,
								{
									id: commitId,
									isRemote: !!branchDetails.remoteTrackingBranch,
									hasConflicts: isLocalAndRemoteCommit(commit) && commit.hasConflicts,
									isIntegrated: isLocalAndRemoteCommit(commit) && commit.state.type === 'Integrated'
								},
								false,
								branchName
							),
							viewportId: 'board-viewport'
						}}
					>
						<CommitRow
							commitId={commit.id}
							commitMessage={commit.message}
							type={commit.state.type}
							hasConflicts={commit.hasConflicts}
							diverged={commit.state.type === 'LocalAndRemote' &&
								commit.id !== commit.state.subject}
							createdAt={commit.createdAt}
							{stackId}
							{branchName}
							{first}
							lastCommit={last}
							{lastBranch}
							{selected}
							draggable
							{tooltip}
							{active}
							isOpen={commit.id === commitMenuContext?.data.commitId}
							onclick={() => handleCommitClick(commit.id, false)}
							disableCommitActions={false}
						>
							{#snippet menu({ rightClickTrigger })}
								{@const data = {
									stackId,
									commitId,
									commitMessage: commit.message,
									commitStatus: commit.state.type,
									commitUrl: forge.current.commitUrl(commitId),
									onUncommitClick: () => handleUncommit(commit.id, branchName),
									onEditMessageClick: () => startEditingCommitMessage(branchName, commit.id),
									onPatchEditClick: () =>
										handleEditPatch({
											commitId: commit.id,
											type: commit.state.type,
											hasConflicts: hasConflicts(commit),
											isAncestorMostConflicted: ancestorMostConflicted?.id === commit.id
										})
								}}
								<KebabButton
									flat
									contextElement={rightClickTrigger}
									onclick={(element) => {
										commitMenuContext = {
											position: { element },
											data
										};
									}}
									oncontext={(coords) =>
										(commitMenuContext = {
											position: { coords },
											data
										})}
									contextElementSelected={selected}
									activated={commit.id === commitMenuContext?.data.commitId &&
										!!commitMenuContext.position.element}
								/>
							{/snippet}
						</CommitRow>
					</div>
				</Dropzone>
				{@render commitReorderDz(stackingReorderDropzoneManager.belowCommit(branchName, commit.id))}
				{#if isCommitting && last}
					<CommitGoesHere
						{first}
						{last}
						selected={exclusiveAction?.parentCommitId === baseSha}
						onclick={() => {
							projectState.exclusiveAction.set({
								type: 'commit',
								stackId,
								branchName,
								parentCommitId: baseSha
							});
						}}
					/>
				{/if}
			{/each}
		</div>
	{/snippet}
</ReduxResult>

{#if commitMenuContext}
	<CommitContextMenu {projectId} bind:context={commitMenuContext} />
{/if}

<style lang="postcss">
	.commit-list {
		display: flex;
		position: relative;
		flex-direction: column;
		border-radius: 0 0 var(--radius-ml) var(--radius-ml);
	}
</style>
