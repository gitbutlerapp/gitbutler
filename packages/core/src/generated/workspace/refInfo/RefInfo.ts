// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.
import type { BranchReference } from './BranchReference';
import type { Stack } from './Stack';
import type { Target } from './Target';

/**
 * The UI-clone of [`crate::RefInfo`].
 * TODO: should also include base-branch data, see `get_base_branch_data()`.
 */
export type RefInfo = {
	/**
	 * The name of the ref that points to a workspace commit,
	 * *or* the name of the first stack segment.
	 */
	workspaceRef: BranchReference | null;
	/**
	 * The stacks visible in the current workspace.
	 *
	 * This is an empty array if the `HEAD` is unborn.
	 * Otherwise, there is one or more stacks.
	 */
	stacks: Array<Stack>;
	/**
	 * The target to integrate workspace stacks into.
	 *
	 * If `None`, this is a local workspace that doesn't know when possibly pushed branches are considered integrated.
	 * This happens when there is a local branch checked out without a remote tracking branch.
	 */
	target: Target | null;
	/**
	 * The `workspace_ref_name` is `Some(_)` and belongs to GitButler, because it had metadata attached.
	 * This will be `false` when in single-branch mode.
	 */
	isManagedRef: boolean;
	/**
	 * The `workspace_ref_name` points to a commit that was specifically created by us.
	 * If the user advanced the workspace head by hand, this would be `false`.
	 * See if `ancestor_workspace_commit` is `Some()` to understand if anything could be fixed here.
	 * If there is no managed commits, we have to be extra careful as to what we allow, but setting
	 * up stacks and dependent branches is usually fine, and limited commit creation. Play it safe though,
	 * this is mainly for graceful handling of special cases.
	 */
	isManagedCommit: boolean;
	/**
	 * The workspace represents what `HEAD` is pointing to.
	 */
	isEntrypoint: boolean;
};
