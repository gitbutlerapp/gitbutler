//! CLI ID generation and mapping for GitButler entities.
//!
//! This module provides a system for generating short, human-friendly IDs for various GitButler
//! entities including branches, commits, and files. These IDs are used in the CLI to make commands
//! more convenient and readable than using full SHA-1 hashes or long branch names.

#![forbid(missing_docs)]

use std::collections::{BTreeMap, HashMap};

use bstr::{BStr, BString, ByteSlice};
use but_core::ref_metadata::StackId;
use but_ctx::Context;
use but_hunk_assignment::HunkAssignment;
use but_workspace::{branch::Stack, ref_info::LocalCommitRelation};
use nonempty::NonEmpty;

use crate::id::{
    file_info::FileInfo, id_usage::IdUsage, stacks_info::StacksInfo,
    uncommitted_info::UncommittedInfo,
};

mod file_info;
mod id_usage;
mod stacks_info;
mod uncommitted_info;

#[cfg(test)]
mod tests;

/// A helper to indicate that this is a short-id as a user would see.
type ShortId = String;

const UNASSIGNED: &str = "zz";

/// A change in a workspace commit.
#[derive(Debug, Clone)]
pub struct TreeChangeWithId {
    /// The short ID.
    pub short_id: ShortId,
    /// The tree change.
    pub inner: but_core::TreeChange,
}

/// A workspace commit with its short ID.
#[derive(Debug, Clone)]
pub struct WorkspaceCommitWithId {
    /// The short ID.
    pub short_id: ShortId,
    /// The original workspace commit.
    pub inner: but_workspace::ref_info::LocalCommit,
    /// When part of [IdMap], this is originally blank, but will be populated
    /// when [IdMap::add_committed_file_info] is called.
    pub tree_changes: Vec<TreeChangeWithId>,
}
impl WorkspaceCommitWithId {
    /// The object ID of the commit.
    pub fn commit_id(&self) -> gix::ObjectId {
        self.inner.inner.id
    }
    /// The ID of the first parent if the commit has parents.
    pub fn first_parent_id(&self) -> Option<gix::ObjectId> {
        self.inner.inner.parent_ids.first().cloned()
    }
    /// State in relation to its remote tracking branch.
    pub fn relation(&self) -> LocalCommitRelation {
        self.inner.relation
    }
}

/// A remote commit with its short ID.
#[derive(Debug, Clone)]
pub struct RemoteCommitWithId {
    /// The short ID.
    pub short_id: ShortId,
    /// The original remote commit.
    pub inner: but_workspace::ref_info::Commit,
}
impl RemoteCommitWithId {
    /// The object ID of the commit.
    pub fn commit_id(&self) -> gix::ObjectId {
        self.inner.id
    }
}

/// A segment with its short ID and commit IDs.
#[derive(Debug, Clone)]
pub struct SegmentWithId {
    /// The short ID.
    pub short_id: ShortId,
    /// True iff `short_id` was generated from scratch (and not from a substring
    /// of the branch name).
    pub is_auto_id: bool,
    /// The original segment except that `commits` and `commits_on_remote` are
    /// blank to save memory.
    pub inner: but_workspace::ref_info::Segment,
    /// The original `inner.commits` with additional information.
    pub workspace_commits: Vec<WorkspaceCommitWithId>,
    /// The original `inner.commits_on_remote` with additional information.
    pub remote_commits: Vec<RemoteCommitWithId>,
}
impl SegmentWithId {
    /// Returns the branch name.
    pub fn branch_name(&self) -> Option<&BStr> {
        self.inner
            .ref_info
            .as_ref()
            .map(|ref_info| ref_info.ref_name.shorten())
    }
    /// Returns the linked worktree ID.
    pub fn linked_worktree_id(&self) -> Option<&BStr> {
        if let Some(ref_info) = &self.inner.ref_info
            && let Some(but_graph::Worktree::LinkedId(id)) = &ref_info.worktree
        {
            Some(id.as_bstr())
        } else {
            None
        }
    }
    /// Returns the PR number.
    pub fn pr_number(&self) -> Option<usize> {
        if let Some(metadata) = &self.inner.metadata {
            metadata.review.pull_request
        } else {
            None
        }
    }
}

/// A stack with segment and commit IDs.
#[derive(Debug, Clone)]
pub struct StackWithId {
    /// Same as [Stack::id].
    pub id: Option<StackId>,
    /// Parallel to the original [Stack::segments].
    pub segments: Vec<SegmentWithId>,
}

/// A mapping from user-friendly CLI IDs to GitButler entities.
///
/// # Lifecycle
///
/// 1. Create an `IdMap` for example using [IdMap::new]
/// 2. Optionally add file information for example using [IdMap::add_committed_file_info_from_context]
/// 3. Use [IdMap::resolve_entity_to_ids] to parse user input into matching IDs
#[derive(Debug)]
pub struct IdMap {
    /// Stacks with segment and commit IDs.
    pub stacks: Vec<StackWithId>,
    /// Maps shortened branch names to their assigned CLI IDs
    branch_name_to_cli_id: BTreeMap<BString, CliId>,
    /// Maps [ShortId]s of branches if they are autogenerated to CLI IDs.
    /// This will be duplicate at least in parts with `branch_name_to_cli_id`.
    branch_auto_id_to_cli_id: HashMap<ShortId, CliId>,
    /// Tracks all non-commit IDs that have been used to avoid collisions.
    /// Needed when adding more IDs to know which one is next.
    id_usage: IdUsage,
    /// Commit IDs reachable from workspace tips with their first parent IDs
    workspace_commits: HashMap<ShortId, WorkspaceCommit>,
    /// Mapping from stack IDs to their corresponding stack CLI IDs.
    stack_ids: BTreeMap<StackId, CliId>,
    /// Commit IDs that are only on the remote
    remote_commit_ids: HashMap<ShortId, gix::ObjectId>,
    /// The ID representing the unassigned area, i.e. uncommitted files that aren't assigned to a stack.
    unassigned: CliId,

    /// Uncommitted files in a mapping from generated `ShortID`s to its file information.
    /// It's public for convenience in `but rub` currently.
    pub uncommitted_files: BTreeMap<ShortId, UncommittedFile>,
    /// Uncommitted hunks.
    pub uncommitted_hunks: HashMap<ShortId, UncommittedHunk>,
    /// Committed files.
    committed_files: BTreeMap<ShortId, CommittedFile>,
}

/// Lifecycle methods for creating and initializing `IdMap` instances.
impl IdMap {
    /// Initializes CLI IDs for branches, commits, and uncommitted
    /// files/hunks. To enable parsing of committed file IDs, call
    /// [IdMap::add_committed_file_info_from_context].
    pub fn new(stacks: Vec<Stack>, hunk_assignments: Vec<HunkAssignment>) -> anyhow::Result<Self> {
        let UncommittedInfo {
            partitioned_hunks,
            uncommitted_short_filenames,
        } = UncommittedInfo::from_hunk_assignments(hunk_assignments)?;
        let StacksInfo {
            stacks,
            mut id_usage,
        } = StacksInfo::new(stacks, &uncommitted_short_filenames)?;

        let mut branch_name_to_cli_id = BTreeMap::new();
        let mut branch_auto_id_to_cli_id = HashMap::new();
        let mut workspace_commits = HashMap::new();
        let mut remote_commit_ids = HashMap::new();
        for segment in stacks.iter().flat_map(|stack| stack.segments.iter()) {
            if let Some(branch_name) = segment.branch_name() {
                let cli_id = CliId::Branch {
                    name: branch_name.to_string(),
                    id: segment.short_id.clone(),
                };
                if segment.is_auto_id {
                    branch_auto_id_to_cli_id.insert(segment.short_id.clone(), cli_id.clone());
                }
                branch_name_to_cli_id.insert(branch_name.to_owned(), cli_id);
            }
            for workspace_commit in segment.workspace_commits.iter() {
                workspace_commits.insert(
                    workspace_commit.short_id.clone(),
                    WorkspaceCommit {
                        commit_id: workspace_commit.commit_id(),
                        first_parent_id: workspace_commit.first_parent_id(),
                    },
                );
            }
            for remote_commit in segment.remote_commits.iter() {
                remote_commit_ids.insert(remote_commit.short_id.clone(), remote_commit.commit_id());
            }
        }

        let mut uncommitted_files = BTreeMap::new();
        let mut uncommitted_hunks = HashMap::new();
        for hunk_assignments in partitioned_hunks {
            uncommitted_files.insert(
                id_usage.next_available()?.to_short_id(),
                UncommittedFile { hunk_assignments },
            );
        }
        for uncommitted_file in uncommitted_files.values() {
            for hunk_assignment in uncommitted_file.hunk_assignments.iter() {
                uncommitted_hunks.insert(
                    id_usage.next_available()?.to_short_id(),
                    UncommittedHunk {
                        hunk_assignment: hunk_assignment.clone(),
                    },
                );
            }
        }
        let mut stack_ids = BTreeMap::new();
        for stack in &stacks {
            if let Some(id) = stack.id {
                stack_ids.insert(
                    id,
                    CliId::Stack {
                        id: id_usage.next_available()?.to_short_id(),
                        stack_id: id,
                    },
                );
            }
        }

        Ok(Self {
            stacks,
            branch_name_to_cli_id,
            branch_auto_id_to_cli_id,
            id_usage,
            workspace_commits,
            stack_ids,
            remote_commit_ids,
            unassigned: CliId::Unassigned {
                id: UNASSIGNED.to_string(),
            },
            uncommitted_files,
            uncommitted_hunks,
            committed_files: BTreeMap::new(),
        })
    }

    /// Creates a new instance from `ctx` for more convenience over calling [IdMap::new].
    pub fn new_from_context(
        ctx: &mut Context,
        assignments: Option<Vec<HunkAssignment>>,
    ) -> anyhow::Result<Self> {
        let guard = ctx.shared_worktree_access();
        let meta = ctx.meta(guard.read_permission())?;

        let hunk_assignments = match assignments {
            Some(assignments) => assignments,
            None => {
                if let Some(worktree_dir) = ctx.workdir()? {
                    let changes =
                        but_core::diff::ui::worktree_changes_by_worktree_dir(worktree_dir)?.changes;
                    let repo = ctx.repo.get()?.clone();
                    let (_, workspace) =
                        ctx.workspace_and_read_only_meta_from_head(guard.read_permission())?;
                    let (assignments, _) = but_hunk_assignment::assignments_with_fallback(
                        ctx,
                        &repo,
                        &workspace,
                        false,
                        Some(changes),
                        None,
                    )?;
                    assignments
                } else {
                    Vec::new()
                }
            }
        };

        let repo = &*ctx.repo.get()?;
        let head_info = but_workspace::head_info(
            repo,
            &meta,
            but_workspace::ref_info::Options {
                expensive_commit_info: false,
                ..Default::default()
            },
        )?;
        Self::new(head_info.stacks, hunk_assignments)
    }
}

/// Methods for adding context to enable file ID generation for the entities it contains.
impl IdMap {
    /// Adds committed file information from a `ctx` to add IDs for all changed
    /// files of all workspace commits.
    pub fn add_committed_file_info_from_context(
        &mut self,
        ctx: &mut Context,
    ) -> anyhow::Result<()> {
        let repo = &*ctx.repo.get()?;
        self.add_committed_file_info(|commit_id, parent_id| {
            but_core::diff::tree_changes(repo, parent_id, commit_id)
        })
    }

    /// Trigger the generation of IDs for committed files and store them in the map.
    ///
    /// It generates unique 2-character hash-based IDs for each file, ensuring no collisions with existing branch
    /// and commit IDs.
    ///
    /// * `changes_in_commit_fn(commit, parent)` returns the changes for a given commit
    ///   and its parent. Used to identify all files altered by workspace commits.
    fn add_committed_file_info<F>(&mut self, changes_in_commit_fn: F) -> anyhow::Result<()>
    where
        F: FnMut(gix::ObjectId, Option<gix::ObjectId>) -> anyhow::Result<Vec<but_core::TreeChange>>,
    {
        let FileInfo { mut changes } = FileInfo::from_workspace_commits_and_status(
            self.workspace_commits.values().map(|workspace_commit| {
                (
                    &workspace_commit.commit_id,
                    &workspace_commit.first_parent_id,
                )
            }),
            changes_in_commit_fn,
        )?;
        for stack in self.stacks.iter_mut() {
            for segment in stack.segments.iter_mut() {
                for workspace_commit in segment.workspace_commits.iter_mut() {
                    let Some(paths_to_changes) = changes.remove(&workspace_commit.commit_id())
                    else {
                        continue;
                    };
                    for (path, changes) in paths_to_changes {
                        let short_id = self.id_usage.next_available()?.to_short_id();
                        for change in changes {
                            workspace_commit.tree_changes.push(TreeChangeWithId {
                                short_id: short_id.clone(),
                                inner: change,
                            });
                        }
                        self.committed_files.insert(
                            short_id,
                            CommittedFile {
                                commit_id: workspace_commit.commit_id(),
                                path,
                            },
                        );
                    }
                }
            }
        }

        Ok(())
    }
}

/// Private methods to individually parse what can appear on both side of a
/// colon. (They can also appear alone.)
impl IdMap {
    // TODO add colon parsing to `resolve_entity_to_ids`

    /// Parses "long" IDs, which take precedence over any "regular" ID.
    fn parse_long_lhs(&self, entity: &str) -> Vec<CliId> {
        let mut matches = Vec::<CliId>::new();
        // Branches match if they match exactly.
        if let Some((_, cli_id)) = self
            .branch_name_to_cli_id
            .iter()
            .find(|(branch_name, _)| *branch_name == entity)
        {
            matches.push(cli_id.clone());
        }
        matches
    }
    /// Parses "regular" IDs.
    fn parse_regular_lhs(&self, entity: &str) -> Vec<CliId> {
        let mut matches = Vec::<CliId>::new();

        // First, try partial branch name match
        matches.extend(
            self.find_branches_by_substring_match(entity.into())
                .map(Clone::clone),
        );

        // Only try SHA matching if the input looks like a hex string
        if entity
            .chars()
            .all(|c| c.is_ascii_hexdigit() && !c.is_ascii_uppercase())
            && let Ok(prefix) = gix::hash::Prefix::from_hex_nonempty(entity)
        {
            for oid in self
                .workspace_and_remote_commit_ids()
                .filter(|oid| prefix.cmp_oid(oid).is_eq())
            {
                matches.push(CliId::Commit {
                    commit_id: *oid,
                    id: entity.to_owned(),
                });
            }
        }

        // handle stack_ids as well
        if let Some(cli_id) = self
            .stack_ids
            .values()
            .find(|cli_id| matches!(cli_id, CliId::Stack { id, .. } if id == entity))
        {
            matches.push(cli_id.clone());
        }

        // Then try CliId matching
        if let Some(cli_id) = self.branch_auto_id_to_cli_id.get(entity) {
            matches.push(cli_id.clone());
        }
        if entity == UNASSIGNED {
            matches.push(self.unassigned.clone());
        }
        matches
    }
    /// Parses filenames of uncommitted files.
    fn parse_uncommitted_filename_rhs(
        &self,
        stack_id: Option<StackId>,
        entity: &str,
    ) -> Vec<CliId> {
        let mut matches = Vec::<CliId>::new();
        for uncommitted_file in self.uncommitted_files.values() {
            let hunk_assignment = uncommitted_file.hunk_assignments.first();
            // TODO once the set of allowed CLI IDs is determined and the
            // access patterns of `uncommitted_files` are known, change its data
            // structure to be more efficient than the current linear search.
            if hunk_assignment.stack_id == stack_id
                && hunk_assignment.path_bytes == entity.as_bytes()
            {
                matches.push(uncommitted_file.to_cli_id(entity.to_owned()));
            }
        }
        matches
    }
    // TODO make a method that parses committed files, and use it in `resolve_entity_to_ids`
}

/// Methods for parsing and generating CLI IDs.
impl IdMap {
    /// Parses a user-provided `entity` name into matching CLI IDs, with each ID matching a single entity.
    /// Multiple IDs may be returned if the entity matches multiple items.
    ///
    /// Besides generated IDs, this method also accepts filenames, which are
    /// interpreted as uncommitted, unassigned files.
    pub fn resolve_entity_to_ids(&self, entity: &str) -> anyhow::Result<Vec<CliId>> {
        // Branches match if they match exactly. Likewise for uncommitted, unassigned files.
        let mut matches = self.parse_long_lhs(entity);
        matches.append(&mut self.parse_uncommitted_filename_rhs(None, entity));
        if !matches.is_empty() {
            return Ok(matches);
        }

        if entity.len() < 2 {
            return Err(anyhow::anyhow!(
                "Id needs to be at least 2 characters long: '{entity}'"
            ));
        }

        matches = self.parse_regular_lhs(entity);
        if let Some(uncommitted_file) = self.uncommitted_files.get(entity) {
            matches.push(uncommitted_file.to_cli_id(entity.to_owned()));
        }
        if let Some(CommittedFile { commit_id, path }) = self.committed_files.get(entity) {
            matches.push(CliId::CommittedFile {
                commit_id: *commit_id,
                path: path.clone(),
                id: entity.to_string(),
            });
        }
        if let Some(uncommitted_hunk) = self.uncommitted_hunks.get(entity) {
            matches.push(CliId::Uncommitted(UncommittedCliId {
                id: entity.to_string(),
                hunk_assignments: NonEmpty::new(uncommitted_hunk.hunk_assignment.clone()),
                is_entire_file: false,
            }));
        }

        Ok(matches)
    }

    /// Returns the [`CliId::Stack`] for a given `stack_id`, if it exists.
    pub fn resolve_stack(&self, stack_id: StackId) -> Option<&CliId> {
        self.stack_ids.get(&stack_id)
    }

    /// Returns the [`CliId::Unassigned`] for the unassigned area, which is useful as an
    /// ID for a destination of operations.
    ///
    /// The unassigned area represents files and changes that are not assigned to any branch.
    pub fn unassigned(&self) -> &CliId {
        &self.unassigned
    }
}

/// Private helper methods for `IdMap`.
impl IdMap {
    /// Finds all branches whose names contain the given `substring`.
    ///
    /// A vector of [`CliId::Branch`] instances for all matching branches.
    fn find_branches_by_substring_match<'a, 's: 'a>(
        &'s self,
        substring: &'a BStr,
    ) -> impl Iterator<Item = &'s CliId> {
        self.branch_name_to_cli_id
            .iter()
            .filter_map(move |(branch_name, cli_id)| {
                branch_name.contains_str(substring).then_some(cli_id)
            })
    }

    /// Returns an iterator over all commit IDs (workspace and remote) known to
    /// this ID map.
    fn workspace_and_remote_commit_ids(&self) -> impl Iterator<Item = &gix::ObjectId> {
        self.workspace_commits
            .values()
            .map(|workspace_commit| &workspace_commit.commit_id)
            .chain(self.remote_commit_ids.values())
    }
}

/// An uncommitted file or hunk in the worktree.
#[derive(Debug, Clone)]
pub struct UncommittedCliId {
    /// The short CLI ID for this file (typically 2 characters)
    pub id: ShortId,
    /// The hunk assignments
    pub hunk_assignments: NonEmpty<HunkAssignment>,
    /// `true` if self represents all hunks in a stack-assignment or file pair.
    /// Note that this file may have hunks with other stack assignments.
    pub is_entire_file: bool,
}

impl UncommittedCliId {
    /// Describes self.
    pub fn describe(&self) -> String {
        let hunk_cardinality = if self.is_entire_file {
            if self.hunk_assignments.len() == 1 {
                "the only hunk"
            } else {
                "all hunks"
            }
        } else {
            "a hunk"
        };
        let assignment = if self.hunk_assignments.first().stack_id.is_some() {
            "a stack"
        } else {
            "the unassigned area"
        };
        format!(
            "{hunk_cardinality} in {} in {assignment}",
            self.hunk_assignments.first().path_bytes,
        )
    }
}

/// A user-friendly CLI ID that identifies a GitButler entity,
/// with each identified by a variant.
///
/// This enum represents the various types of entities that can be identified
/// by short CLI IDs. Each variant contains the necessary information to
/// uniquely identify the entity along with its short ID that one could use
/// to find it.
#[derive(Debug, Clone)]
pub enum CliId {
    /// An uncommitted file or hunk in the worktree.
    Uncommitted(UncommittedCliId),
    /// A file that exists in a commit.
    CommittedFile {
        /// The object ID of the commit containing the change to the file
        commit_id: gix::ObjectId,
        /// The file path relative to the repository root
        path: BString,
        /// The short CLI ID for this file (typically 2 characters)
        id: ShortId,
    },
    /// A branch.
    Branch {
        /// The short name of the branch, like `main` or `origin/feat`.
        name: String,
        /// The short CLI ID for this branch (typically 2 characters)
        id: ShortId,
    },
    /// A commit in the workspace identified by its SHA.
    Commit {
        /// The object ID of the commit.
        commit_id: gix::ObjectId,
        /// The short CLI ID, a prefix of the object ID. This prefix is unique
        /// among all commits in all stacks (but not necessarily among all
        /// commits in the repo).
        id: ShortId,
    },
    /// The unassigned area, as a designated area that files can be put in.
    Unassigned {
        /// The CLI ID for the unassigned area.
        id: ShortId,
    },
    /// A stack in the workspace.
    Stack {
        /// The short CLI ID for this stack (typically 2 characters)
        id: ShortId,
        /// The stack ID.
        stack_id: StackId,
    },
}
impl PartialEq for CliId {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (
                Self::Uncommitted(UncommittedCliId { id: l_id, .. }),
                Self::Uncommitted(UncommittedCliId { id: r_id, .. }),
            ) => l_id == r_id,
            (Self::CommittedFile { id: l_id, .. }, Self::CommittedFile { id: r_id, .. }) => {
                l_id == r_id
            }
            (Self::Branch { id: l_id, .. }, Self::Branch { id: r_id, .. }) => l_id == r_id,
            (Self::Commit { id: l_id, .. }, Self::Commit { id: r_id, .. }) => l_id == r_id,
            (Self::Unassigned { .. }, Self::Unassigned { .. }) => true,
            _ => false,
        }
    }
}
impl Eq for CliId {}

/// Methods for accessing `CliId` information.
impl CliId {
    /// Returns a human-readable description of the entity type.
    pub fn kind_for_humans(&self) -> &'static str {
        match self {
            CliId::Uncommitted { .. } => "an uncommitted file or hunk",
            CliId::CommittedFile { .. } => "a committed file",
            CliId::Branch { .. } => "a branch",
            CliId::Commit { .. } => "a commit",
            CliId::Unassigned { .. } => "the unassigned area",
            CliId::Stack { .. } => "a stack",
        }
    }

    /// Returns the short ID string for display to users.
    pub fn to_short_string(&self) -> ShortId {
        match self {
            CliId::Uncommitted(UncommittedCliId { id, .. })
            | CliId::CommittedFile { id, .. }
            | CliId::Branch { id, .. }
            | CliId::Commit { id, .. }
            | CliId::Stack { id, .. }
            | CliId::Unassigned { id, .. } => id.clone(),
        }
    }
}

/// Internal representation of a workspace commit.
#[derive(Debug, Clone)]
struct WorkspaceCommit {
    /// The object ID of the commit.
    commit_id: gix::ObjectId,
    /// The ID of the first parent if the commit has parents.
    first_parent_id: Option<gix::ObjectId>,
}

/// Internal representation of an uncommitted file.
#[derive(Debug, Clone)]
pub struct UncommittedFile {
    /// Every element has the same [HunkAssignment::stack_id] and [HunkAssignment::path_bytes],
    /// so the first assignment can be used to obtain both.
    pub hunk_assignments: NonEmpty<HunkAssignment>,
}

impl UncommittedFile {
    /// Return the file's stack if it is associated to one, or `None` if the Stack is unknown/has no ID.
    pub fn stack_id(&self) -> Option<StackId> {
        self.hunk_assignments.first().stack_id
    }
    /// The path of the uncommitted file.
    pub fn path(&self) -> &BStr {
        self.hunk_assignments.first().path_bytes.as_ref()
    }
    /// Turn this instance into a [CliId], using `id` for identification.
    pub fn to_cli_id(&self, id: ShortId) -> CliId {
        CliId::Uncommitted(UncommittedCliId {
            hunk_assignments: self.hunk_assignments.clone(),
            id,
            is_entire_file: true,
        })
    }
}

/// Internal representation of a committed file with its CLI ID.
#[derive(Debug)]
struct CommittedFile {
    commit_id: gix::ObjectId,
    path: BString,
}

/// An uncommitted hunk.
#[derive(Debug)]
pub struct UncommittedHunk {
    /// The hunk assignment.
    pub hunk_assignment: HunkAssignment,
}
