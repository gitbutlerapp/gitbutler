//! Generate TypeScript type definitions from JSON schemas registered by `#[but_api]` functions.
//!
//! This binary collects all type schemas registered in the `but-api` crate,
//! converts them to TypeScript type definitions, and
//! writes them to a `.d.ts` file.
//!
//! Usage:
//! ```
//!  but-ts --output <path>
//! ```
//!
//!
//! Example:
//! ```
//! but-ts --output packages/but-sdk/generated/types.d.ts
//! ```
//!

use std::collections::BTreeMap;
use std::fmt::Write;
use std::path::PathBuf;

fn main() -> anyhow::Result<()> {
    let output_path = parse_args()?;

    // Collect schemas from the but-api schema registry
    let schemas = but_api::schema::collect_all_schemas();

    eprintln!("Collected {} unique type schemas", schemas.len());

    // Convert schemas to JSON values for processing
    let json_schemas: Vec<(String, serde_json::Value)> = schemas
        .into_iter()
        .filter_map(|(name, schema)| serde_json::to_value(&schema).ok().map(|v| (name.to_string(), v)))
        .collect();

    let mut ts_output = String::new();
    writeln!(ts_output, "// Auto-generated by but-ts. Do not edit manually.")?;
    writeln!(
        ts_output,
        "// Generated from JSON schemas registered by #[but_api] functions.\n"
    )?;

    // Sort by name for stable output
    let mut sorted: BTreeMap<&str, &serde_json::Value> = BTreeMap::new();
    for (name, schema) in &json_schemas {
        sorted.insert(name.as_str(), schema);
    }

    // First pass: collect all $defs from all schemas.
    let mut all_defs: BTreeMap<String, serde_json::Value> = BTreeMap::new();
    for schema in sorted.values() {
        if let Some(obj) = schema.as_object()
            && let Some(serde_json::Value::Object(defs)) = obj.get("$defs").or_else(|| obj.get("definitions"))
        {
            for (def_name, def_schema) in defs {
                all_defs.entry(def_name.clone()).or_insert_with(|| def_schema.clone());
            }
        }
    }

    // Generate top-level types
    for (name, schema) in &sorted {
        if let Some(desc) = get_description(schema) {
            write!(ts_output, "{}", format_jsdoc(&desc, 0))?;
        }
        let ts_type = schema_to_ts(schema, 0);
        writeln!(ts_output, "export type {name} = {ts_type};\n")?;
    }

    // Generate types from $defs
    for (name, schema) in &all_defs {
        // Skip if already generated as a top-level type
        if sorted.contains_key(name.as_str()) {
            continue;
        }
        if let Some(desc) = get_description(schema) {
            write!(ts_output, "{}", format_jsdoc(&desc, 0))?;
        }
        let ts_type = schema_to_ts(schema, 0);
        writeln!(ts_output, "export type {name} = {ts_type};\n")?;
    }

    // Write output
    if let Some(parent) = output_path.parent() {
        std::fs::create_dir_all(parent)?;
    }

    let mut final_output = ts_output.clone();
    if output_path.exists() {
        let existing = std::fs::read_to_string(&output_path)?;
        final_output = format!("{}\n{}", existing, ts_output);
    }

    std::fs::write(&output_path, &final_output)?;
    eprintln!("Written to {}", output_path.display());

    Ok(())
}

fn parse_args() -> anyhow::Result<PathBuf> {
    let mut args = std::env::args().skip(1);
    let mut output = None;
    while let Some(arg) = args.next() {
        match arg.as_str() {
            "--output" | "-o" => {
                output = Some(PathBuf::from(
                    args.next()
                        .ok_or_else(|| anyhow::anyhow!("--output requires a path argument"))?,
                ));
            }
            "--help" | "-h" => {
                eprintln!("Usage: but-ts --output <path>");
                std::process::exit(0);
            }
            other => {
                anyhow::bail!("Unknown argument: {other}");
            }
        }
    }
    output.ok_or_else(|| anyhow::anyhow!("--output is required"))
}

/// Extract the `description` field from a JSON Schema value, if present.
fn get_description(schema: &serde_json::Value) -> Option<String> {
    schema
        .as_object()
        .and_then(|obj| obj.get("description"))
        .and_then(|v| v.as_str())
        .map(|s| s.to_string())
}

/// Format a description string as a JSDoc comment with proper indentation.
fn format_jsdoc(description: &str, indent: usize) -> String {
    let padding = "  ".repeat(indent);
    let lines: Vec<&str> = description.lines().collect();
    if lines.len() == 1 {
        format!("{padding}/** {description} */\n")
    } else {
        let mut out = format!("{padding}/**\n");
        for line in &lines {
            if line.is_empty() {
                out.push_str(&format!("{padding} *\n"));
            } else {
                out.push_str(&format!("{padding} * {line}\n"));
            }
        }
        out.push_str(&format!("{padding} */\n"));
        out
    }
}

/// Convert a JSON Schema (as serde_json::Value) to a TypeScript type string.
fn schema_to_ts(schema: &serde_json::Value, indent: usize) -> String {
    // Handle boolean schemas
    match schema {
        serde_json::Value::Bool(true) => return "any".to_string(),
        serde_json::Value::Bool(false) => return "never".to_string(),
        _ => {}
    }

    let obj = match schema.as_object() {
        Some(o) => o,
        None => return "any".to_string(),
    };

    // Handle $ref
    if let Some(ref_val) = obj.get("$ref")
        && let Some(ref_str) = ref_val.as_str()
    {
        if let Some(type_name) = ref_str
            .strip_prefix("#/$defs/")
            .or_else(|| ref_str.strip_prefix("#/definitions/"))
        {
            return type_name.to_string();
        }
        return "any".to_string();
    }
    // Handle const
    if let Some(const_val) = obj.get("const") {
        return match const_val {
            serde_json::Value::String(s) => format!("\"{}\"", s.replace('"', "\\\"")),
            serde_json::Value::Number(n) => n.to_string(),
            serde_json::Value::Bool(b) => b.to_string(),
            serde_json::Value::Null => "null".to_string(),
            _ => "any".to_string(),
        };
    }

    // Handle enum (string literals)
    if let Some(enum_vals) = obj.get("enum")
        && let Some(arr) = enum_vals.as_array()
    {
        let variants: Vec<String> = arr
            .iter()
            .map(|v| match v {
                serde_json::Value::String(s) => format!("\"{}\"", s.replace('"', "\\\"")),
                serde_json::Value::Number(n) => n.to_string(),
                serde_json::Value::Bool(b) => b.to_string(),
                serde_json::Value::Null => "null".to_string(),
                _ => "any".to_string(),
            })
            .collect();
        return variants.join(" | ");
    }

    // Handle oneOf (discriminated unions)
    if let Some(one_of) = obj.get("oneOf")
        && let Some(arr) = one_of.as_array()
    {
        let variants: Vec<String> = arr.iter().map(|s| schema_to_ts(s, indent)).collect();
        return variants.join(" | ");
    }

    // Handle anyOf
    if let Some(any_of) = obj.get("anyOf")
        && let Some(arr) = any_of.as_array()
    {
        // Special case: anyOf with exactly 2 items where one is null → T | null
        if arr.len() == 2 {
            let is_null: Vec<bool> = arr
                .iter()
                .map(|s| s.as_object().and_then(|o| o.get("type")).and_then(|t| t.as_str()) == Some("null"))
                .collect();
            if is_null[0] {
                return format!("{} | null", schema_to_ts(&arr[1], indent));
            }
            if is_null[1] {
                return format!("{} | null", schema_to_ts(&arr[0], indent));
            }
        }
        let variants: Vec<String> = arr.iter().map(|s| schema_to_ts(s, indent)).collect();
        return variants.join(" | ");
    }

    // Handle allOf (intersection)
    if let Some(all_of) = obj.get("allOf")
        && let Some(arr) = all_of.as_array()
    {
        let parts: Vec<String> = arr.iter().map(|s| schema_to_ts(s, indent)).collect();
        return parts.join(" & ");
    }

    // Handle union type
    let type_field = obj.get("type");
    if let Some(type_field) = type_field
        && type_field.is_array()
    {
        let type_variants: Vec<String> = type_field
            .as_array()
            .unwrap_or(&vec![])
            .iter()
            .filter_map(|t| t.as_str())
            .map(|t| match t {
                "string" => "string".to_string(),
                "number" | "integer" => "number".to_string(),
                "boolean" => "boolean".to_string(),
                "null" => "null".to_string(),
                "array" => "Array<any>".to_string(),
                "object" => "Record<string, unknown>".to_string(),
                _ => "any".to_string(),
            })
            .collect();
        return type_variants.join(" | ");
    }

    // Handle type field
    let type_val = type_field.and_then(|t| t.as_str());
    match type_val {
        Some("string") => "string".to_string(),
        Some("number" | "integer") => "number".to_string(),
        Some("boolean") => "boolean".to_string(),
        Some("null") => "null".to_string(),
        Some("array") => {
            if let Some(items) = obj.get("items") {
                let item_ty = schema_to_ts(items, indent);
                format!("Array<{item_ty}>")
            } else {
                "Array<any>".to_string()
            }
        }
        Some("object") => {
            if let Some(props) = obj.get("properties") {
                if let Some(props_obj) = props.as_object() {
                    let required: Vec<String> = obj
                        .get("required")
                        .and_then(|r| r.as_array())
                        .map(|arr| arr.iter().filter_map(|v| v.as_str().map(String::from)).collect())
                        .unwrap_or_default();

                    let next_indent = indent + 1;
                    let padding = "  ".repeat(next_indent);
                    let close_padding = "  ".repeat(indent);

                    let mut fields: Vec<String> = Vec::new();
                    for (key, value) in props_obj {
                        let doc = if let Some(desc) = get_description(value) {
                            format_jsdoc(&desc, next_indent)
                        } else {
                            "".to_string()
                        };
                        let ts_type = schema_to_ts(value, next_indent);
                        let optional = if required.contains(key) { "" } else { "?" };
                        fields.push(format!("{doc}{padding}{key}{optional}: {ts_type};"));
                    }

                    if fields.is_empty() {
                        "Record<string, unknown>".to_string()
                    } else {
                        format!("{{\n{}\n{close_padding}}}", fields.join("\n"))
                    }
                } else {
                    "Record<string, unknown>".to_string()
                }
            } else if let Some(additional) = obj.get("additionalProperties") {
                let val_ty = schema_to_ts(additional, indent);
                format!("Record<string, {val_ty}>")
            } else {
                "Record<string, unknown>".to_string()
            }
        }
        _ => {
            // No type field — might have properties directly (implicit object)
            if obj.contains_key("properties") {
                let mut obj_with_type = obj.clone();
                obj_with_type.insert("type".to_string(), serde_json::Value::String("object".to_string()));
                schema_to_ts(&serde_json::Value::Object(obj_with_type), indent)
            } else {
                "any".to_string()
            }
        }
    }
}
