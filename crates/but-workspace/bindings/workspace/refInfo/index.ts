// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.
import type { Branch } from "../../core/refMetadata/index";
import type { Commit, PushStatus, UpstreamCommit } from "../index";

/**
 * A reference in `refs/heads`.
 */
export type BranchReference = { 
/**
 * The full ref name, like `refs/heads/feat`, for usage with the backend.
 */
fullNameBytes: number[], 
/**
 * The short version of `full_name_bytes` for display.
 */
displayName: string, };

/**
 * The UI-clone of [`crate::RefInfo`].
 * TODO: should also include base-branch data, see `get_base_branch_data()`.
 */
export type RefInfo = { 
/**
 * The name of the ref that points to a workspace commit,
 * *or* the name of the first stack segment.
 */
workspaceRef: BranchReference | null, 
/**
 * The stacks visible in the current workspace.
 *
 * This is an empty array if the `HEAD` is unborn.
 * Otherwise, there is one or more stacks.
 */
stacks: Array<Stack>, 
/**
 * The target to integrate workspace stacks into.
 *
 * If `None`, this is a local workspace that doesn't know when possibly pushed branches are considered integrated.
 * This happens when there is a local branch checked out without a remote tracking branch.
 */
target: Target | null, 
/**
 * The `workspace_ref_name` is `Some(_)` and belongs to GitButler, because it had metadata attached.
 * This will be `false` when in single-branch mode.
 */
isManagedRef: boolean, 
/**
 * The `workspace_ref_name` points to a commit that was specifically created by us.
 * If the user advanced the workspace head by hand, this would be `false`.
 * See if `ancestor_workspace_commit` is `Some()` to understand if anything could be fixed here.
 * If there is no managed commits, we have to be extra careful as to what we allow, but setting
 * up stacks and dependent branches is usually fine, and limited commit creation. Play it safe though,
 * this is mainly for graceful handling of special cases.
 */
isManagedCommit: boolean, 
/**
 * The workspace represents what `HEAD` is pointing to.
 */
isEntrypoint: boolean, };

/**
 * A reference in `refs/remotes`.
 */
export type RemoteTrackingReference = { 
/**
 * The full ref name, like `refs/remotes/origin/on-remote`, for usage with the backend.
 */
fullNameBytes: number[], 
/**
 * The short version of `full_name_bytes` for display, like `on-remote`, without the remote name.
 */
displayName: string, 
/**
 * The symbolic name of the remote, like `origin`, or `origin/other`.
 */
remoteName: string, };

/**
 * A segment of a commit graph, representing a set of commits exclusively.
 */
export type Segment = { 
/**
 *
 * It is `None` if this branch is the top-most stack segment and the `ref_name` wasn't pointing to
 * a commit anymore that was reached by our rev-walk.
 * This can happen if the ref is deleted, or if it was advanced by other means.
 * Alternatively, the naming would have been ambiguous.
 * Finally, this is `None` of the original name can be found searching upwards, finding exactly one
 * named segment.
 */
refName: BranchReference | null, 
/**
 * The name of the remote tracking branch of this segment, if present, i.e. `refs/remotes/origin/main`.
 * Its presence means that a remote is configured and that the stack content
 */
remoteTrackingRefName: RemoteTrackingReference | null, 
/**
 * The portion of commits that can be reached from the tip of the *branch* downwards, so that they are unique
 * for that stack segment and not included in any other stack or stack segment.
 *
 * The list could be empty for when this is a dedicated empty segment as insertion position of commits.
 */
commits: Array<Commit>, 
/**
 * Commits that are reachable from the remote-tracking branch associated with this branch,
 * but are not reachable from this branch or duplicated by a commit in it.
 * Note that commits that are also similar to commits in `commits` are pruned, and not present here.
 *
 * Note that remote commits along with their remote tracking branch should always retain a shared history
 * with the local tracking branch. If these diverge, we can represent this in data, but currently there is
 * no derived value to make this visible explicitly.
 */
commitsOnRemote: Array<UpstreamCommit>, 
/**
 * All commits *that are not workspace commits* reachable by (and including commits in) this segment.
 * The list was created by walking all parents, not only the first parent.
 * This means the segment needs fixing.
 */
commitsOutside: Array<Commit> | null, 
/**
 * Read-only metadata with additional information about the branch naming the segment,
 * or `None` if nothing was present.
 */
metadata: Branch | null, 
/**
 * This is `true` a segment in a workspace if the entrypoint of [the traversal](Graph::from_commit_traversal())
 * is this segment, and the surrounding workspace is provided for context.
 *
 * This means one will see the entire workspace, while knowing the focus is on one specific segment.
 * *Note* that this segment can be listed in *multiple stacks* as it's reachable from multiple 'ahead' segments.
 */
isEntrypoint: boolean, 
/**
 * A derived value to help the UI decide which functions to make available.
 */
pushStatus: PushStatus, 
/**
 * This is always the `first()` commit in `commits` of the next stacksegment, or the first commit of
 * the first ancestor segment.
 * It can be imagined as the base upon which the segment is resting, or the connection point to the rest
 * of the commit-graph along the first parent.
 * It is `None` if the stack segment contains the first commit in the history, an orphan without ancestry,
 * or if the history traversal was stopped early.
 */
base: string | null, };

/**
 * The UI-clone of [`branch::Stack`].
 */
export type Stack = { 
/**
 * Otherwise, it is `None`.
 */
id: string | null, 
/**
 * If there is an integration branch, we know a base commit shared with the integration branch from
 * which we branched off.
 * Otherwise, it's the merge-base of all stacks in the current workspace.
 * It is `None` if this is a stack derived from a branch without relation to any other branch.
 */
base: string | null, 
/**
 * The branch-name denoted segments of the stack from its tip to the point of reference, typically a merge-base.
 * This array is never empty.
 */
segments: Array<Segment>, };

/**
 * Information about the target reference, the one we want to integrate with.
 */
export type Target = { 
/**
 * The remote tracking branch of the target to integrate with, like `refs/remotes/origin/main`.
 */
remoteTrackingRef: RemoteTrackingReference, 
/**
 * The amount of commits that aren't reachable by any segment in the workspace, they are in its future.
 */
commitsAhead: number, };
