[
	{
		"id": "sc-vbranches-cli:425",
		"name": "sc-vbranches-cli",
		"active": true,
		"kind": "branch",
		"files": [
			{
				"id": "sc-vbranches-cli:pnpm-lock.yaml",
				"path": "pnpm-lock.yaml",
				"kind": "file",
				"hunks": [
					{
						"id": "sc-vbranches-cli:pnpm-lock.yaml:1",
						"name": "Updated lockfile version and added settings for dependencies.",
						"diff": "@@ -1,4 +1,8 @@\n-lockfileVersion: '6.0'\n+lockfileVersion: '6.1'\n+\n+settings:\n+  autoInstallPeers: true\n+  excludeLinksFromLockfile: false\n \n devDependencies:\n   '@codemirror/autocomplete':\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "pnpm-lock.yaml"
					}
				]
			},
			{
				"id": "sc-vbranches-cli:src-tauri/Cargo.lock",
				"path": "src-tauri/Cargo.lock",
				"kind": "file",
				"hunks": [
					{
						"id": "sc-vbranches-cli:src-tauri/Cargo.lock:93",
						"name": "Added dependencies for several Rust packages.",
						"diff": "@@ -93,6 +93,55 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"anstream\"\n+version = \"0.3.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0ca84f3628370c59db74ee214b3263d58f9aadd9b4fe7e711fd87dc452b7f163\"\n+dependencies = [\n+ \"anstyle\",\n+ \"anstyle-parse\",\n+ \"anstyle-query\",\n+ \"anstyle-wincon\",\n+ \"colorchoice\",\n+ \"is-terminal\",\n+ \"utf8parse\",\n+]\n+\n+[[package]]\n+name = \"anstyle\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"41ed9a86bf92ae6580e0a31281f65a1b1d867c0cc68d5346e2ae128dddfa6a7d\"\n+\n+[[package]]\n+name = \"anstyle-parse\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e765fd216e48e067936442276d1d57399e37bce53c264d6fefbe298080cb57ee\"\n+dependencies = [\n+ \"utf8parse\",\n+]\n+\n+[[package]]\n+name = \"anstyle-query\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5ca11d4be1bab0c8bc8734a9aa7bf4ee8316d462a08c6ac5052f888fef5b494b\"\n+dependencies = [\n+ \"windows-sys 0.48.0\",\n+]\n+\n+[[package]]\n+name = \"anstyle-wincon\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"180abfa45703aebe0093f79badacc01b8fd4ea2e35118747e5811127f926e188\"\n+dependencies = [\n+ \"anstyle\",\n+ \"windows-sys 0.48.0\",\n+]\n+\n [[package]]\n name = \"anyhow\"\n version = \"1.0.71\"\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/Cargo.lock"
					},
					{
						"id": "sc-vbranches-cli:src-tauri/Cargo.lock:520",
						"name": "Added new dependencies for \"clap\" package.",
						"diff": "@@ -471,6 +520,48 @@ dependencies = [\n  \"generic-array\",\n ]\n \n+[[package]]\n+name = \"clap\"\n+version = \"4.3.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ca8f255e4b8027970e78db75e78831229c9815fdbfa67eb1a1b777a62e24b4a0\"\n+dependencies = [\n+ \"clap_builder\",\n+ \"clap_derive\",\n+ \"once_cell\",\n+]\n+\n+[[package]]\n+name = \"clap_builder\"\n+version = \"4.3.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"acd4f3c17c83b0ba34ffbc4f8bbd74f079413f747f84a6f89292f138057e36ab\"\n+dependencies = [\n+ \"anstream\",\n+ \"anstyle\",\n+ \"bitflags 1.3.2\",\n+ \"clap_lex\",\n+ \"strsim 0.10.0\",\n+]\n+\n+[[package]]\n+name = \"clap_derive\"\n+version = \"4.3.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b8cd2b2a819ad6eec39e8f1d6b53001af1e5469f8c177579cdaeb313115b825f\"\n+dependencies = [\n+ \"heck 0.4.1\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn 2.0.16\",\n+]\n+\n+[[package]]\n+name = \"clap_lex\"\n+version = \"0.5.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2da6da31387c7e4ef160ffab6d5e7f00c42626fe39aea70a7b0f1773f7dd6c1b\"\n+\n [[package]]\n name = \"cocoa\"\n version = \"0.24.1\"\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/Cargo.lock"
					},
					{
						"id": "sc-vbranches-cli:src-tauri/Cargo.lock:599",
						"name": "Added new package \"colorchoice\" version 1.0.0.",
						"diff": "@@ -508,6 +599,12 @@ version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3d7b894f5411737b7867f4827955924d7c254fc9f4d91a6aad6b097804b1018b\"\n \n+[[package]]\n+name = \"colorchoice\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"acbf1af155f9b9ef647e42cdc158db4b64a1b61f743629225fde6f3e0be2a7c7\"\n+\n [[package]]\n name = \"colored\"\n version = \"1.9.3\"\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/Cargo.lock"
					},
					{
						"id": "sc-vbranches-cli:src-tauri/Cargo.lock:616",
						"name": "Added \"colored\" package with version 2.0.0 and dependencies.",
						"diff": "@@ -519,6 +616,17 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"colored\"\n+version = \"2.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b3616f750b84d8f0de8a58bda93e08e2a81ad3f523089b05f1dffecab48c6cbd\"\n+dependencies = [\n+ \"atty\",\n+ \"lazy_static\",\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"combine\"\n version = \"4.6.6\"\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/Cargo.lock"
					},
					{
						"id": "sc-vbranches-cli:src-tauri/Cargo.lock:646",
						"name": "Added console package and its dependencies to dependencies list.",
						"diff": "@@ -538,6 +646,19 @@ dependencies = [\n  \"crossbeam-utils\",\n ]\n \n+[[package]]\n+name = \"console\"\n+version = \"0.15.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c926e00cc70edefdc64d3a5ff31cc65bb97a3460097762bd23afb4d8145fccf8\"\n+dependencies = [\n+ \"encode_unicode\",\n+ \"lazy_static\",\n+ \"libc\",\n+ \"unicode-width\",\n+ \"windows-sys 0.45.0\",\n+]\n+\n [[package]]\n name = \"constant_time_eq\"\n version = \"0.1.5\"\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/Cargo.lock"
					},
					{
						"id": "sc-vbranches-cli:src-tauri/Cargo.lock:977",
						"name": "Added dependency on \"dialoguer\" package with its version and checksum.",
						"diff": "@@ -856,6 +977,18 @@ dependencies = [\n  \"syn 1.0.109\",\n ]\n \n+[[package]]\n+name = \"dialoguer\"\n+version = \"0.10.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"59c6f2989294b9a498d3ad5491a79c6deb604617378e1cdc4bfc1c1361fe2f87\"\n+dependencies = [\n+ \"console\",\n+ \"shell-words\",\n+ \"tempfile\",\n+ \"zeroize\",\n+]\n+\n [[package]]\n name = \"digest\"\n version = \"0.10.6\"\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/Cargo.lock"
					},
					{
						"id": "sc-vbranches-cli:src-tauri/Cargo.lock:1011",
						"name": "Added package \"dirs\" and its dependencies.",
						"diff": "@@ -878,6 +1011,15 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"dirs\"\n+version = \"5.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"44c45a9d03d6676652bcb5e724c7e988de1acad23a711b5217ab9cbecbec2225\"\n+dependencies = [\n+ \"dirs-sys\",\n+]\n+\n [[package]]\n name = \"dirs-next\"\n version = \"2.0.0\"\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/Cargo.lock"
					},
					{
						"id": "sc-vbranches-cli:src-tauri/Cargo.lock:1030",
						"name": "Added dirs-sys 0.4.1 package with dependencies.",
						"diff": "@@ -888,6 +1030,18 @@ dependencies = [\n  \"dirs-sys-next\",\n ]\n \n+[[package]]\n+name = \"dirs-sys\"\n+version = \"0.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"520f05a5cbd335fae5a99ff7a6ab8627577660ee5cfd6a94a6a929b52ff0321c\"\n+dependencies = [\n+ \"libc\",\n+ \"option-ext\",\n+ \"redox_users 0.4.3\",\n+ \"windows-sys 0.48.0\",\n+]\n+\n [[package]]\n name = \"dirs-sys-next\"\n version = \"0.1.2\"\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/Cargo.lock"
					},
					{
						"id": "sc-vbranches-cli:src-tauri/Cargo.lock:1225",
						"name": "The `colored` dependency is updated to version 1.9.3.",
						"diff": "@@ -1071,7 +1225,7 @@ version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d9f0c14694cbd524c8720dd69b0e3179344f04ebb5f90f2e4a440c6ea3b2f1ee\"\n dependencies = [\n- \"colored\",\n+ \"colored 1.9.3\",\n  \"log\",\n ]\n \n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/Cargo.lock"
					},
					{
						"id": "sc-vbranches-cli:src-tauri/Cargo.lock:1624",
						"name": "Added 5 dependencies to version 0.0.0 including clap and colored.",
						"diff": "@@ -1470,6 +1624,10 @@ version = \"0.0.0\"\n dependencies = [\n  \"anyhow\",\n  \"bytes\",\n+ \"clap\",\n+ \"colored 2.0.0\",\n+ \"dialoguer\",\n+ \"dirs 5.0.1\",\n  \"filetime\",\n  \"fslock\",\n  \"futures\",\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/Cargo.lock"
					},
					{
						"id": "sc-vbranches-cli:src-tauri/Cargo.lock:2190",
						"name": "Added package \"is-terminal\" with dependencies in version 0.4.7.",
						"diff": "@@ -2032,6 +2190,18 @@ version = \"2.7.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"12b6ee2129af8d4fb011108c73d99a1b83a85977f23b82460c0ae2e25bb4b57f\"\n \n+[[package]]\n+name = \"is-terminal\"\n+version = \"0.4.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"adcf93614601c8129ddf72e2d5633df827ba6551541c6d8c59520a371475be1f\"\n+dependencies = [\n+ \"hermit-abi 0.3.1\",\n+ \"io-lifetimes\",\n+ \"rustix\",\n+ \"windows-sys 0.48.0\",\n+]\n+\n [[package]]\n name = \"itertools\"\n version = \"0.10.5\"\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/Cargo.lock"
					},
					{
						"id": "sc-vbranches-cli:src-tauri/Cargo.lock:3032",
						"name": "Two packages added, including \"option-ext\" 0.2.0, with a source from github.",
						"diff": "@@ -2862,6 +3032,12 @@ dependencies = [\n  \"vcpkg\",\n ]\n \n+[[package]]\n+name = \"option-ext\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"04744f49eae99ab78e0d5c0b603ab218f515ea8cfe5a456d7629ad883a3b6e7d\"\n+\n [[package]]\n name = \"os_info\"\n version = \"3.7.0\"\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/Cargo.lock"
					},
					{
						"id": "sc-vbranches-cli:src-tauri/Cargo.lock:4988",
						"name": "The \"dirs\" dependency updated to version 1.0.5.",
						"diff": "@@ -4812,7 +4988,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"edd106a334b7657c10b7c540a0106114feadeb4dc314513e97df481d5d966f42\"\n dependencies = [\n  \"byteorder\",\n- \"dirs\",\n+ \"dirs 1.0.5\",\n  \"winapi\",\n ]\n \n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/Cargo.lock"
					},
					{
						"id": "sc-vbranches-cli:src-tauri/Cargo.lock:5440",
						"name": "Added package \"utf8parse\" version 0.2.1 with checksum.",
						"diff": "@@ -5264,6 +5440,12 @@ version = \"0.1.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"5190c9442dcdaf0ddd50f37420417d219ae5261bbf5db120d0f9bab996c9cba1\"\n \n+[[package]]\n+name = \"utf8parse\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"711b9620af191e0cdc7468a8d14e709c3dcdb115b36f838e601583af800a370a\"\n+\n [[package]]\n name = \"uuid\"\n version = \"1.3.3\"\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/Cargo.lock"
					},
					{
						"id": "sc-vbranches-cli:src-tauri/Cargo.lock:6111",
						"name": "Added dependency \"zeroize\" version 1.6.0 from crates.io.",
						"diff": "@@ -5929,6 +6111,12 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"zeroize\"\n+version = \"1.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2a0956f1ba7c7909bfb66c2e9e4124ab6f6482560f6628b5aaeba39207c9aad9\"\n+\n [[package]]\n name = \"zip\"\n version = \"0.6.5\"\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/Cargo.lock"
					}
				]
			},
			{
				"id": "sc-vbranches-cli:src-tauri/Cargo.toml",
				"path": "src-tauri/Cargo.toml",
				"kind": "file",
				"hunks": [
					{
						"id": "sc-vbranches-cli:src-tauri/Cargo.toml:14",
						"name": "Added dependency on Clap version 4.0 with features.",
						"diff": "@@ -14,6 +14,7 @@ rust-version = \"1.57\"\n tauri-build = { version = \"1.2\", features = [] }\n \n [dependencies]\n+clap = { version = \"4.0\", features = [\"derive\"] }\n serde = { version = \"1.0\", features = [\"derive\"] }\n tauri = { version = \"1.2\", features = [\"dialog-open\", \"fs-read-file\", \"path-all\", \"protocol-asset\", \"shell-open\", \"system-tray\", \"window-start-dragging\"] }\n tauri-plugin-window-state = { git = \"https://github.com/tauri-apps/plugins-workspace\", branch = \"v1\" }\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/Cargo.toml"
					},
					{
						"id": "sc-vbranches-cli:src-tauri/Cargo.toml:54",
						"name": "Added dependencies: colored 2.0.0, dirs 5.0.1, dialoguer 0.10.4.",
						"diff": "@@ -53,6 +54,9 @@ rusqlite = { version = \"0.28.0\", features = [ \"bundled\", \"blob\" ] }\n refinery = { version = \"0.8\", features = [ \"rusqlite\" ] }\n sha1 = \"0.10.5\"\n tokio-util = \"0.7.8\"\n+colored = \"2.0.0\"\n+dirs = \"5.0.1\"\n+dialoguer = \"0.10.4\"\n \n [features]\n # by default Tauri runs in production mode\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/Cargo.toml"
					}
				]
			},
			{
				"id": "sc-vbranches-cli:src-tauri/src/bin/butler.rs",
				"path": "src-tauri/src/bin/butler.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "sc-vbranches-cli:src-tauri/src/bin/butler.rs:1",
						"name": "Adds command line interface for git_butler_tauri with various dependencies.",
						"diff": "@@ -0,0 +1,189 @@\n+use clap::Parser;\n+use colored::Colorize;\n+use git2::Repository;\n+use dirs;\n+use dialoguer::{console::Term, theme::ColorfulTheme, Select};\n+\n+use git_butler_tauri::{\n+    projects, storage, project_repository, gb_repository,\n+    users, database, sessions, virtual_branches\n+};\n+\n+#[derive(Parser)]\n+struct Cli {\n+    command: String\n+}\n+\n+struct ButlerCli {\n+    path: String,\n+    local_data_dir: String,\n+    project: projects::Project,\n+    gb_repository: gb_repository::Repository,\n+    sessions_db: sessions::Database,\n+}\n+\n+impl ButlerCli {\n+    fn from(path: &str, local_data_dir: &str) -> Self {\n+        let storage = storage::Storage::from_path(local_data_dir);\n+        let users_storage = users::Storage::new(storage.clone());\n+\n+        let projects_storage = projects::Storage::new(storage.clone());\n+        let projects = projects_storage.list_projects().unwrap();\n+        let project = projects.into_iter().find(|p| p.path == path).unwrap();\n+\n+        let gb_repository = gb_repository::Repository::open(\n+            local_data_dir.to_string(),\n+            project.id.clone(),\n+            projects_storage,\n+            users_storage,\n+        )\n+        .expect(\"failed to open repository\");\n+\n+        let db_path = std::path::Path::new(&local_data_dir).join(\"database.sqlite3\");\n+        let database = database::Database::open(&db_path).unwrap();\n+        let sessions_db = sessions::Database::new(database.clone());\n+\n+        Self {\n+            path: path.to_string(),\n+            local_data_dir: local_data_dir.to_string(),\n+            project: project.clone(),\n+            gb_repository,\n+            sessions_db,\n+        }\n+    }\n+\n+    fn project_repository(&self) -> project_repository::Repository {\n+        project_repository::Repository::open(&self.project).unwrap()\n+    }\n+\n+    fn git_repository(&self) -> git2::Repository {\n+        git2::Repository::open(&self.path).unwrap()\n+    }\n+}\n+\n+fn main() {\n+    // setup project repository and gb_repository\n+    let local_data_dir = find_local_data_dir().unwrap();\n+    let path = find_git_directory().unwrap();\n+\n+    let butler = ButlerCli::from(&path, &local_data_dir);\n+\n+    let args = Cli::parse();\n+    match args.command.as_str() {\n+        \"status\" => {\n+            run_status(butler);\n+        },\n+        \"setup\" => {\n+            run_setup(butler);\n+        },\n+        _ => println!(\"Unknown command: {}\", args.command)\n+    }\n+}\n+\n+fn run_setup(butler: ButlerCli) {\n+    println!(\"  HEAD: {}\", butler.project_repository().get_head().unwrap().name().unwrap().blue());\n+    let repo = butler.git_repository();\n+    let items = butler.project_repository().git_remote_branches().unwrap();\n+\n+    let selection = Select::with_theme(&ColorfulTheme::default())\n+        .items(&items)\n+        .default(0)\n+        .interact_on_opt(&Term::stderr()).unwrap();\n+\n+    match selection {\n+        Some(index) => {\n+            println!(\"Setting target to: {}\", items[index].red());\n+\n+            // lookup a branch by name\n+            let branch = repo.find_branch(&items[index], git2::BranchType::Remote).unwrap();\n+\n+            let remote = repo.branch_remote_name(&branch.get().name().unwrap()).unwrap();\n+            let remote_url = repo.find_remote(remote.as_str().unwrap()).unwrap();\n+            let remote_url_str = remote_url.url().unwrap();\n+            println!(\"remote: {}\", remote_url_str);\n+\n+            let target = virtual_branches::target::Target {\n+                name: branch.name().unwrap().unwrap().to_string(),\n+                remote: remote_url_str.to_string(),\n+                sha: branch.get().peel_to_commit().unwrap().id(),\n+            };\n+\n+            let target_writer = virtual_branches::target::Writer::new(&butler.gb_repository);\n+            target_writer.write_default(&target).unwrap();\n+        }\n+        None => println!(\"User did not select anything\")\n+    }\n+}\n+\n+// just print status information for the project\n+fn run_status(butler: ButlerCli) {\n+    println!(\"path: {}\", butler.path.yellow());\n+    println!(\"data_dir: {}\", butler.local_data_dir.yellow());\n+\n+    // find the project in project storage that matches the cwd\n+    println!(\"{}\", \"project:\".to_string().red());\n+    println!(\"  id: {}\", butler.project.id.blue());\n+    println!(\"  title: {}\", butler.project.title.blue());\n+    println!(\"  description: {}\", butler.project.description.clone().unwrap_or(\"none\".to_string()).blue());\n+    println!(\"  last_fetched_ts: {:?}\", butler.project.last_fetched_ts);\n+    println!(\"  path: {}\", butler.project.path.blue());\n+\n+    let api = butler.project.api.as_ref().unwrap();\n+    println!(\"  {}:\", \"api\".to_string().red());\n+    println!(\"   api name: {}\", api.name.blue());\n+    println!(\"   api description: {}\", api.description.clone().unwrap().blue());\n+    println!(\"   repo id: {}\", api.repository_id.blue());\n+    println!(\"   git url: {}\", api.git_url.blue());\n+    println!(\"   created: {}\", api.created_at.blue());\n+    println!(\"   updated: {}\", api.updated_at.blue());\n+\n+    println!(\"{}\", \"project repo:\".to_string().red());\n+    println!(\"  HEAD: {}\", butler.project_repository().get_head().unwrap().name().unwrap().blue());\n+\n+    println!(\"{}\", \"sessions:\".to_string().red());\n+    // sessions storage\n+    let sessions = butler.sessions_db.list_by_project_id(&butler.project.id, butler.project.last_fetched_ts).unwrap();\n+    //list the sessions\n+    for session in &sessions {\n+        println!(\"  id: {}\", session.id.blue());\n+    }\n+\n+    // gitbutler repo stuff\n+    // read default target\n+    println!(\"{}\", \"default target:\".to_string().red());\n+    if let Ok(Some(session)) = butler.gb_repository.get_current_session() {\n+        let session_reader = sessions::Reader::open(&butler.gb_repository, &session).unwrap();\n+\n+        let branch_reader = virtual_branches::target::Reader::new(&session_reader);\n+        if let Ok(target) = branch_reader.read_default() {\n+            println!(\"  name: {}\", target.name.blue());\n+            println!(\"  remote: {}\", target.remote.blue());\n+            println!(\"  sha: {}\", target.sha.to_string().blue());\n+        }\n+\n+        println!(\"{}\", \"virtual branches:\".to_string().red());\n+        let mut iter = virtual_branches::Iterator::new(&session_reader).unwrap();\n+        while let Some(item) = iter.next() {\n+            if let Ok(item) = item {\n+                println!(\"{:?}\", item);\n+            }\n+        }\n+    }\n+}\n+\n+fn find_git_directory() -> Option<String> {\n+    match Repository::discover(\"./\") {\n+        Ok(repo) => {\n+            let mut path = repo.workdir().map(|path| path.to_string_lossy().to_string()).unwrap();\n+            path = path.trim_end_matches('/').to_string();\n+            Some(path)\n+        },\n+        Err(_) => None,\n+    }\n+}\n+\n+fn find_local_data_dir() -> Option<String> {\n+    let mut path = dirs::config_dir().unwrap();\n+    path.push(\"com.gitbutler.app.dev\");\n+    Some(path.to_string_lossy().to_string())\n+}\n\\ No newline at end of file\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/src/bin/butler.rs"
					}
				]
			},
			{
				"id": "sc-vbranches-cli:src-tauri/src/lib.rs",
				"path": "src-tauri/src/lib.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "sc-vbranches-cli:src-tauri/src/lib.rs:1",
						"name": "Added 22 modules and extern crate to Rust project",
						"diff": "@@ -0,0 +1,23 @@\n+#[macro_use(defer)]\n+extern crate scopeguard;\n+\n+pub mod app;\n+pub mod bookmarks;\n+pub mod database;\n+pub mod deltas;\n+pub mod events;\n+pub mod files;\n+pub mod fs;\n+pub mod gb_repository;\n+pub mod project_repository;\n+pub mod projects;\n+pub mod pty;\n+pub mod reader;\n+pub mod search;\n+pub mod sessions;\n+pub mod storage;\n+pub mod users;\n+pub mod virtual_branches;\n+pub mod watcher;\n+pub mod writer;\n+pub mod zip;\n\\ No newline at end of file\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/src/lib.rs"
					}
				]
			},
			{
				"id": "sc-vbranches-cli:src-tauri/src/project_repository/repository.rs",
				"path": "src-tauri/src/project_repository/repository.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "sc-vbranches-cli:src-tauri/src/project_repository/repository.rs:258",
						"name": "Added function to retrieve remote branches in Repository struct.",
						"diff": "@@ -258,6 +258,19 @@ impl<'repository> Repository<'repository> {\n         Ok(branches)\n     }\n \n+    pub fn git_remote_branches(&self) -> Result<Vec<String>> {\n+        let mut branches = vec![];\n+        for branch in self\n+            .git_repository\n+            .branches(Some(git2::BranchType::Remote))?\n+        {\n+            let (branch, _) = branch?;\n+            let name = branch.name()?.unwrap().to_string();\n+            branches.push(name);\n+        }\n+        Ok(branches)\n+    }\n+\n     pub fn git_switch_branch(&self, branch: &str) -> Result<()> {\n         let branch = self\n             .git_repository\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/src/project_repository/repository.rs"
					}
				]
			},
			{
				"id": "sc-vbranches-cli:src-tauri/src/virtual_branches/target/reader.rs",
				"path": "src-tauri/src/virtual_branches/target/reader.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "sc-vbranches-cli:src-tauri/src/virtual_branches/target/reader.rs:11",
						"name": "`pub fn read_default` changed from private to public.",
						"diff": "@@ -11,7 +11,7 @@ impl<'reader> TargetReader<'reader> {\n         Self { reader }\n     }\n \n-    fn read_default(&self) -> Result<Target, reader::Error> {\n+    pub fn read_default(&self) -> Result<Target, reader::Error> {\n         if !self.reader.exists(\"branches/target\") {\n             return Err(reader::Error::NotFound);\n         }\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T14:05:31Z",
						"filePath": "src-tauri/src/virtual_branches/target/reader.rs"
					}
				]
			}
		],
		"description": "CLI binary for simple virtual branch manipulation\nThis PR introduces a CLI tool called `butler` that loads parts of the GitButler Rust libraries and directly makes calls to them, rather than running them through the Tauri JS/Rust bridge. I am looking to more quickly test out examples and debug data without having to reload the whole Tauri app with each change."
	},
	{
		"id": "mbg-more-dry:429",
		"name": "mbg-more-dry",
		"active": true,
		"kind": "branch",
		"files": [
			{
				"id": "mbg-more-dry:src/routes/projects_new/[projectId]/Board.svelte",
				"path": "src/routes/projects_new/[projectId]/Board.svelte",
				"kind": "file",
				"hunks": [
					{
						"id": "mbg-more-dry:src/routes/projects_new/[projectId]/Board.svelte:4",
						"name": "Adds import of helper functions and types.",
						"diff": "@@ -4,6 +4,7 @@\n \timport Lane from './BranchLane.svelte';\n \timport type { Branch, Commit, File, Hunk } from './types';\n \timport type { DndEvent } from 'svelte-dnd-action/typings';\n+\timport { createBranch, createCommit, createFile } from './helpers';\n \n \texport let branches: Branch[];\n \n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T15:44:07Z",
						"filePath": "src/routes/projects_new/[projectId]/Board.svelte"
					},
					{
						"id": "mbg-more-dry:src/routes/projects_new/[projectId]/Board.svelte:20",
						"name": "Replace old branch item creation with new helper functions.",
						"diff": "@@ -19,56 +20,41 @@\n \t\tconst hunkItems = e.detail.items.filter((item) => item.kind == 'hunk') as Hunk[];\n \n \t\tfor (const hunk of hunkItems) {\n-\t\t\tbranchItems.push({\n-\t\t\t\tid: `${Date.now()}-${hunk.id}-branch`,\n-\t\t\t\tname: 'new branch',\n-\t\t\t\tactive: true,\n-\t\t\t\tkind: 'branch',\n-\t\t\t\tcommits: [\n-\t\t\t\t\t{\n-\t\t\t\t\t\tid: `${Date.now()}-${hunk.id}-commit`,\n-\t\t\t\t\t\tdescription: 'New commit',\n-\t\t\t\t\t\tkind: 'commit',\n-\t\t\t\t\t\tfiles: [\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tid: `${Date.now()}-${hunk.id}-hunk`,\n-\t\t\t\t\t\t\t\tpath: hunk.filePath,\n-\t\t\t\t\t\t\t\tkind: 'file',\n-\t\t\t\t\t\t\t\thunks: [{ ...hunk, isDndShadowItem: !isFinal }]\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t]\n-\t\t\t\t\t}\n-\t\t\t\t]\n-\t\t\t});\n+\t\t\tbranchItems.push(\n+\t\t\t\tcreateBranch({\n+\t\t\t\t\tcommits: [\n+\t\t\t\t\t\tcreateCommit({\n+\t\t\t\t\t\t\tfiles: [\n+\t\t\t\t\t\t\t\tcreateFile({\n+\t\t\t\t\t\t\t\t\thunks: [{ ...hunk, isDndShadowItem: !isFinal }],\n+\t\t\t\t\t\t\t\t\tisShadow: false,\n+\t\t\t\t\t\t\t\t\tfilePath: hunk.filePath\n+\t\t\t\t\t\t\t\t})\n+\t\t\t\t\t\t\t],\n+\t\t\t\t\t\t\tisShadow: false\n+\t\t\t\t\t\t})\n+\t\t\t\t\t]\n+\t\t\t\t})\n+\t\t\t);\n \t\t}\n \t\tfor (const file of fileItems) {\n-\t\t\tbranchItems.push({\n-\t\t\t\tid: `${Date.now()}-${file.id}-branch`,\n-\t\t\t\tname: 'new branch',\n-\t\t\t\tactive: true,\n-\t\t\t\tkind: 'branch',\n-\t\t\t\tcommits: [\n-\t\t\t\t\t{\n-\t\t\t\t\t\tid: `${Date.now()}-${file.id}-commit`,\n-\t\t\t\t\t\tdescription: '',\n-\t\t\t\t\t\tkind: 'commit',\n-\t\t\t\t\t\tfiles: [{ ...file, isDndShadowItem: false }],\n-\t\t\t\t\t\tisDndShadowItem: !isFinal\n-\t\t\t\t\t}\n-\t\t\t\t]\n-\t\t\t});\n+\t\t\tbranchItems.push(\n+\t\t\t\tcreateBranch({\n+\t\t\t\t\tcommits: [\n+\t\t\t\t\t\tcreateCommit({ files: [{ ...file, isDndShadowItem: !isFinal }], isShadow: false })\n+\t\t\t\t\t]\n+\t\t\t\t})\n+\t\t\t);\n \t\t}\n \t\tfor (const commit of commitItems) {\n-\t\t\tbranchItems.push({\n-\t\t\t\tid: `${Date.now()}-${commit.id}-branch`,\n-\t\t\t\tname: 'new branch',\n-\t\t\t\tkind: 'branch',\n-\t\t\t\tactive: true,\n-\t\t\t\tcommits: [commit],\n-\t\t\t\tisDndShadowItem: !isFinal\n-\t\t\t});\n+\t\t\tbranchItems.push(\n+\t\t\t\tcreateBranch({\n+\t\t\t\t\tcommits: [commit]\n+\t\t\t\t})\n+\t\t\t);\n \t\t}\n \t\tbranches = branchItems.filter((commit) => commit.active);\n+\t\tconsole.log(branches);\n \t}\n \n \tfunction handleEmpty() {\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T15:44:07Z",
						"filePath": "src/routes/projects_new/[projectId]/Board.svelte"
					}
				]
			},
			{
				"id": "mbg-more-dry:src/routes/projects_new/[projectId]/BranchLane.svelte",
				"path": "src/routes/projects_new/[projectId]/BranchLane.svelte",
				"kind": "file",
				"hunks": [
					{
						"id": "mbg-more-dry:src/routes/projects_new/[projectId]/BranchLane.svelte:5",
						"name": "Added import of helper functions to file.",
						"diff": "@@ -5,6 +5,7 @@\n \timport type { Commit, File, Hunk } from './types';\n \timport CommitGroup from './CommitGroup.svelte';\n \timport { createEventDispatcher } from 'svelte';\n+\timport { createCommit, createFile } from './helpers';\n \n \texport let name: string;\n \texport let commits: Commit[];\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T15:44:07Z",
						"filePath": "src/routes/projects_new/[projectId]/BranchLane.svelte"
					},
					{
						"id": "mbg-more-dry:src/routes/projects_new/[projectId]/BranchLane.svelte:20",
						"name": "Loop through hunks and files, create new commits with associated files.",
						"diff": "@@ -19,28 +20,23 @@\n \n \t\t// Merge hunks into existing files, or create new where none exist\n \t\tfor (const hunk of hunkItems) {\n-\t\t\tcommitItems.push({\n-\t\t\t\tid: `${Date.now()}-${hunk.id}-commit`,\n-\t\t\t\tdescription: 'New commit',\n-\t\t\t\tkind: 'commit',\n-\t\t\t\tfiles: [\n-\t\t\t\t\t{\n-\t\t\t\t\t\tid: `${Date.now()}-${hunk.id}-hunk`,\n-\t\t\t\t\t\tpath: hunk.filePath,\n-\t\t\t\t\t\tkind: 'file',\n-\t\t\t\t\t\thunks: [{ ...hunk, isDndShadowItem: !isFinal }]\n-\t\t\t\t\t}\n-\t\t\t\t]\n-\t\t\t});\n+\t\t\tcommitItems.push(\n+\t\t\t\tcreateCommit({\n+\t\t\t\t\tfiles: [\n+\t\t\t\t\t\tcreateFile({\n+\t\t\t\t\t\t\thunks: [{ ...hunk, isDndShadowItem: !isFinal }],\n+\t\t\t\t\t\t\tisShadow: false,\n+\t\t\t\t\t\t\tfilePath: hunk.filePath\n+\t\t\t\t\t\t})\n+\t\t\t\t\t],\n+\t\t\t\t\tisShadow: false\n+\t\t\t\t})\n+\t\t\t);\n \t\t}\n \t\tfor (const file of fileItems) {\n-\t\t\tcommitItems.push({\n-\t\t\t\tid: `${Date.now()}-${file.id}`,\n-\t\t\t\tdescription: 'New commit',\n-\t\t\t\tkind: 'commit',\n-\t\t\t\tfiles: [{ ...file, isDndShadowItem: false }],\n-\t\t\t\tisDndShadowItem: !isFinal\n-\t\t\t});\n+\t\t\tcommitItems.push(\n+\t\t\t\tcreateCommit({ files: [{ ...file, isDndShadowItem: true }], isShadow: false })\n+\t\t\t);\n \t\t}\n \t\tcommits = commitItems.filter((commit) => commit.files && commit.files.length > 0);\n \n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T15:44:07Z",
						"filePath": "src/routes/projects_new/[projectId]/BranchLane.svelte"
					}
				]
			},
			{
				"id": "mbg-more-dry:src/routes/projects_new/[projectId]/CommitGroup.svelte",
				"path": "src/routes/projects_new/[projectId]/CommitGroup.svelte",
				"kind": "file",
				"hunks": [
					{
						"id": "mbg-more-dry:src/routes/projects_new/[projectId]/CommitGroup.svelte:5",
						"name": "Add import statement for \"createFile\" helper function.",
						"diff": "@@ -5,6 +5,7 @@\n \timport type { File, Hunk } from './types';\n \timport FileCard from './FileCard.svelte';\n \timport { createEventDispatcher } from 'svelte';\n+\timport { createFile } from './helpers';\n \n \texport let description: string;\n \texport let id: string;\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T15:44:07Z",
						"filePath": "src/routes/projects_new/[projectId]/CommitGroup.svelte"
					},
					{
						"id": "mbg-more-dry:src/routes/projects_new/[projectId]/CommitGroup.svelte:24",
						"name": "This git diff hunk adds a function to create a file item and pushes it to an array of file items.",
						"diff": "@@ -23,12 +24,13 @@\n \t\t\tif (file) {\n \t\t\t\tfile.hunks.push(hunk);\n \t\t\t} else {\n-\t\t\t\tfileItems.push({\n-\t\t\t\t\tid: `${Date.now()}-${hunk.id}`,\n-\t\t\t\t\tpath: hunk.filePath,\n-\t\t\t\t\tkind: 'file',\n-\t\t\t\t\thunks: [{ ...hunk, isDndShadowItem: !isFinal }]\n-\t\t\t\t});\n+\t\t\t\tfileItems.push(\n+\t\t\t\t\tcreateFile({\n+\t\t\t\t\t\tfilePath: hunk.filePath,\n+\t\t\t\t\t\thunks: [{ ...hunk, isDndShadowItem: !isFinal }],\n+\t\t\t\t\t\tisShadow: false\n+\t\t\t\t\t})\n+\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\tfiles = fileItems.filter((file) => file.hunks && file.hunks.length > 0);\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T15:44:07Z",
						"filePath": "src/routes/projects_new/[projectId]/CommitGroup.svelte"
					}
				]
			},
			{
				"id": "mbg-more-dry:src/routes/projects_new/[projectId]/helpers.ts",
				"path": "src/routes/projects_new/[projectId]/helpers.ts",
				"kind": "file",
				"hunks": [
					{
						"id": "mbg-more-dry:src/routes/projects_new/[projectId]/helpers.ts:1",
						"name": "Added functions to create File, Commit, and Branch in 'types.js'.",
						"diff": "@@ -1,11 +1,38 @@\n-import type { Commit, File } from './types';\n+import type { Branch, Commit, File, Hunk } from './types';\n \n-export function createCommit(files: File[], isShadow: boolean): Commit {\n+let fileCounter = 0;\n+let commitCounter = 0;\n+let branchCounter = 0;\n+\n+export function createFile(args: { hunks: [Hunk]; filePath: string; isShadow: boolean }): File {\n+\tfileCounter++;\n+\treturn {\n+\t\tid: `file-${fileCounter}`,\n+\t\tpath: args.filePath,\n+\t\tkind: 'file',\n+\t\thunks: args.hunks,\n+\t\tisDndShadowItem: args.isShadow\n+\t};\n+}\n+\n+export function createCommit(args: { files: File[]; isShadow: boolean }): Commit {\n+\tcommitCounter++;\n \treturn {\n-\t\tid: `commit-${Date.now()}`,\n-\t\tdescription: '',\n+\t\tid: `commit-${commitCounter}`,\n+\t\tdescription: `New commit # ${commitCounter}`,\n \t\tkind: 'commit',\n-\t\tfiles: files,\n-\t\tisDndShadowItem: isShadow\n+\t\tfiles: args.files,\n+\t\tisDndShadowItem: args.isShadow\n+\t};\n+}\n+\n+export function createBranch(args: { commits: Commit[] }): Branch {\n+\tbranchCounter++;\n+\treturn {\n+\t\tid: `branch-${branchCounter}`,\n+\t\tname: `new branch ${branchCounter}`,\n+\t\tactive: true,\n+\t\tkind: 'branch',\n+\t\tcommits: args.commits\n \t};\n }\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-13T15:44:07Z",
						"filePath": "src/routes/projects_new/[projectId]/helpers.ts"
					}
				]
			}
		],
		"description": "Make drag & drop code a bit more dry\n"
	},
	{
		"id": "Branch-sidebar-is-stuck-to-side-of-the-window:420",
		"name": "Branch-sidebar-is-stuck-to-side-of-the-window",
		"active": true,
		"kind": "branch",
		"files": [
			{
				"id": "Branch-sidebar-is-stuck-to-side-of-the-window:src/routes/projects_new/[projectId]/+page.svelte",
				"path": "src/routes/projects_new/[projectId]/+page.svelte",
				"kind": "file",
				"hunks": [
					{
						"id": "Branch-sidebar-is-stuck-to-side-of-the-window:src/routes/projects_new/[projectId]/+page.svelte:9",
						"name": "Removed 'gap-x-4' class from a 'div' element.",
						"diff": "@@ -9,7 +9,7 @@\n \t$: console.log(columnsData);\n </script>\n \n-<div class=\"flex h-full gap-x-4 p-4\">\n+<div class=\"flex h-full\">\n \t<Tray bind:columns={columnsData} />\n \t<Board bind:columns={columnsData} />\n </div>\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-09T15:18:26Z",
						"filePath": "src/routes/projects_new/[projectId]/+page.svelte"
					}
				]
			},
			{
				"id": "Branch-sidebar-is-stuck-to-side-of-the-window:src/routes/projects_new/[projectId]/Board.svelte",
				"path": "src/routes/projects_new/[projectId]/Board.svelte",
				"kind": "file",
				"hunks": [
					{
						"id": "Branch-sidebar-is-stuck-to-side-of-the-window:src/routes/projects_new/[projectId]/Board.svelte:10",
						"name": "Adds padding to a CSS class in a section element.",
						"diff": "@@ -10,7 +10,7 @@\n </script>\n \n <section\n-\tclass=\"flex gap-x-4\"\n+\tclass=\"flex gap-x-4 p-4\"\n \tuse:dndzone={{ items: columns, flipDurationMs, type: 'column' }}\n \ton:consider={(e) => (columns = e.detail.items)}\n \ton:finalize={(e) => (columns = e.detail.items)}\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-09T15:18:26Z",
						"filePath": "src/routes/projects_new/[projectId]/Board.svelte"
					}
				]
			},
			{
				"id": "Branch-sidebar-is-stuck-to-side-of-the-window:src/routes/projects_new/[projectId]/Tray.svelte",
				"path": "src/routes/projects_new/[projectId]/Tray.svelte",
				"kind": "file",
				"hunks": [
					{
						"id": "Branch-sidebar-is-stuck-to-side-of-the-window:src/routes/projects_new/[projectId]/Tray.svelte:6",
						"name": "Changes section class to remove background and add border.",
						"diff": "@@ -6,9 +6,7 @@\n \texport let columns: BranchLane[];\n </script>\n \n-<section\n-\tclass=\"flex h-full w-64 flex-col gap-y-4 rounded border border-zinc-700 bg-zinc-900/50 p-4\"\n->\n+<section class=\"flex h-full w-64 flex-col gap-y-4 border-r border-zinc-700 bg-[#2F2F33] p-4\">\n \t{#each columns as column (column.id)}\n \t\t<div animate:flip={{ duration: 150 }} class=\"rounded border border-zinc-600 bg-zinc-700 p-2\">\n \t\t\t<Checkbox bind:checked={column.active} />\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-09T15:18:26Z",
						"filePath": "src/routes/projects_new/[projectId]/Tray.svelte"
					}
				]
			}
		],
		"description": "Branch sidebar is stuck to side of the window\n"
	},
	{
		"id": "watcher-work-w:414",
		"name": "watcher-work-w",
		"active": true,
		"kind": "branch",
		"files": [
			{
				"id": "watcher-work-w:src-tauri/src/app.rs",
				"path": "src-tauri/src/app.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "watcher-work-w:src-tauri/src/app.rs:131",
						"name": "Git diff changes spawn_blocking() to spawn(async move) for a project's repository watcher.",
						"diff": "@@ -131,21 +131,13 @@ impl App {\n             .unwrap()\n             .insert(project.id.clone(), proxy_tx);\n \n-        tauri::async_runtime::spawn_blocking(|| {\n+        tauri::async_runtime::spawn(async move {\n             let project = project;\n-\n-            let gb_repository = gb_repository::Repository::open(\n-                local_data_dir,\n-                project.id.clone(),\n-                projects_storage.clone(),\n-                users_storage,\n-            )\n-            .expect(\"failed to open git repository\");\n-\n             let watcher = watcher::Watcher::new(\n+                local_data_dir,\n                 &project,\n                 projects_storage,\n-                &gb_repository,\n+                users_storage,\n                 deltas_searcher,\n                 cancellation_token,\n                 events_sender,\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/app.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/app.rs:148",
						"name": "Changed how `watcher.start` is called using async/await syntax.",
						"diff": "@@ -156,7 +148,10 @@ impl App {\n             )\n             .expect(\"failed to create watcher\");\n \n-            futures::executor::block_on(watcher.start(proxy_rx)).expect(\"failed to init watcher\");\n+            watcher\n+                .start(proxy_rx)\n+                .await\n+                .expect(\"failed to init watcher\");\n         });\n \n         Ok(())\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/app.rs"
					}
				]
			},
			{
				"id": "watcher-work-w:src-tauri/src/watcher/handlers/check_current_session.rs",
				"path": "src-tauri/src/watcher/handlers/check_current_session.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/check_current_session.rs:1",
						"name": "The diff updates the Handler struct to include new fields.",
						"diff": "@@ -1,27 +1,43 @@\n-use std::{sync, time};\n+use std::{path, time};\n \n use anyhow::{Context, Result};\n \n-use crate::{gb_repository, sessions};\n+use crate::{gb_repository, projects, sessions, users};\n \n use super::events;\n \n-pub struct Handler<'handler> {\n-    gb_repository: sync::Arc<sync::Mutex<&'handler gb_repository::Repository>>,\n+#[derive(Clone)]\n+pub struct Handler {\n+    project_id: String,\n+    project_store: projects::Storage,\n+    local_data_dir: path::PathBuf,\n+    user_store: users::Storage,\n }\n \n-impl<'handler> Handler<'handler> {\n-    pub fn new(gb_repository: &'handler gb_repository::Repository) -> Self {\n+impl<'handler> Handler {\n+    pub fn new(\n+        local_data_dir: path::PathBuf,\n+        project_id: String,\n+        project_store: projects::Storage,\n+        user_store: users::Storage,\n+    ) -> Self {\n         Self {\n-            gb_repository: sync::Arc::new(sync::Mutex::new(gb_repository)),\n+            project_id,\n+            project_store,\n+            local_data_dir,\n+            user_store,\n         }\n     }\n \n     pub fn handle(&self, now: time::SystemTime) -> Result<Vec<events::Event>> {\n-        match self\n-            .gb_repository\n-            .lock()\n-            .unwrap()\n+        let gb_repo = gb_repository::Repository::open(\n+            &self.local_data_dir,\n+            self.project_id.clone(),\n+            self.project_store.clone(),\n+            self.user_store.clone(),\n+        )\n+        .context(\"failed to open repository\")?;\n+        match gb_repo\n             .get_current_session()\n             .context(\"failed to get current session\")?\n         {\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/check_current_session.rs"
					}
				]
			},
			{
				"id": "watcher-work-w:src-tauri/src/watcher/handlers/check_fetch_project.rs",
				"path": "src-tauri/src/watcher/handlers/check_fetch_project.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/check_fetch_project.rs:6",
						"name": "Added `#[derive(Clone)]` to `Handler` struct definition.",
						"diff": "@@ -6,6 +6,7 @@ use crate::projects;\n \n use super::events;\n \n+#[derive(Clone)]\n pub struct Handler {\n     project_id: String,\n     project_storage: projects::Storage,\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/check_fetch_project.rs"
					}
				]
			},
			{
				"id": "watcher-work-w:src-tauri/src/watcher/handlers/fetch_project.rs",
				"path": "src-tauri/src/watcher/handlers/fetch_project.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/fetch_project.rs:1",
						"name": "Added `users::Storage` and `local_data_dir` to `Handler` struct.",
						"diff": "@@ -1,37 +1,48 @@\n-use std::time;\n+use std::{path, time};\n \n use anyhow::{Context, Result};\n \n-use crate::{gb_repository, projects};\n+use crate::{gb_repository, projects, users};\n \n use super::events;\n \n-pub struct Handler<'handler> {\n+#[derive(Clone)]\n+pub struct Handler {\n     project_id: String,\n     project_storage: projects::Storage,\n-    gb_repository: &'handler gb_repository::Repository,\n+    local_data_dir: path::PathBuf,\n+    user_storage: users::Storage,\n }\n \n-impl<'handler> Handler<'handler> {\n+impl Handler {\n     pub fn new(\n+        local_data_dir: path::PathBuf,\n         project_id: String,\n         project_storage: projects::Storage,\n-        gb_repository: &'handler gb_repository::Repository,\n+        user_storage: users::Storage,\n     ) -> Self {\n         Self {\n             project_id,\n             project_storage,\n-            gb_repository,\n+            user_storage,\n+            local_data_dir,\n         }\n     }\n \n     pub fn handle(&self) -> Result<Vec<events::Event>> {\n-        let sessions_before_fetch = self\n-            .gb_repository\n+        let gb_rep = gb_repository::Repository::open(\n+            self.local_data_dir.clone(),\n+            self.project_id.clone(),\n+            self.project_storage.clone(),\n+            self.user_storage.clone(),\n+        )\n+        .context(\"failed to open repository\")?;\n+\n+        let sessions_before_fetch = gb_rep\n             .get_sessions_iterator()?\n             .filter_map(|s| s.ok())\n             .collect::<Vec<_>>();\n-        if !self.gb_repository.fetch().context(\"failed to fetch\")? {\n+        if !gb_rep.fetch().context(\"failed to fetch\")? {\n             return Ok(vec![]);\n         }\n \n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/fetch_project.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/fetch_project.rs:59",
						"name": "Changed code retrieves sessions from a different variable.",
						"diff": "@@ -48,8 +59,7 @@ impl<'handler> Handler<'handler> {\n             })\n             .context(\"failed to update project\")?;\n \n-        let sessions_after_fetch = self\n-            .gb_repository\n+        let sessions_after_fetch = gb_rep\n             .get_sessions_iterator()?\n             .filter_map(|s| s.ok())\n             .collect::<Vec<_>>();\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/fetch_project.rs"
					}
				]
			},
			{
				"id": "watcher-work-w:src-tauri/src/watcher/handlers/file_change.rs",
				"path": "src-tauri/src/watcher/handlers/file_change.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/file_change.rs:2",
						"name": "Added a derive macro for the Clone trait to Handler struct.",
						"diff": "@@ -2,6 +2,7 @@ use anyhow::Result;\n \n use crate::watcher::events;\n \n+#[derive(Clone)]\n pub struct Handler {}\n \n impl Handler {\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/file_change.rs"
					}
				]
			},
			{
				"id": "watcher-work-w:src-tauri/src/watcher/handlers/flush_session.rs",
				"path": "src-tauri/src/watcher/handlers/flush_session.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/flush_session.rs:1",
						"name": "Added `local_data_dir` and `user_store` to `Handler` struct.",
						"diff": "@@ -1,25 +1,31 @@\n+use std::path;\n+\n use anyhow::{anyhow, Context, Result};\n \n-use crate::{gb_repository, project_repository, projects, sessions};\n+use crate::{gb_repository, project_repository, projects, sessions, users};\n \n use super::events;\n \n-pub struct Handler<'handler> {\n+#[derive(Clone)]\n+pub struct Handler {\n     project_id: String,\n     project_store: projects::Storage,\n-    gb_repository: &'handler gb_repository::Repository,\n+    local_data_dir: path::PathBuf,\n+    user_store: users::Storage,\n }\n \n-impl<'listener> Handler<'listener> {\n+impl<'listener> Handler {\n     pub fn new(\n+        local_data_dir: path::PathBuf,\n         project_id: String,\n         project_store: projects::Storage,\n-        gb_repository: &'listener gb_repository::Repository,\n+        user_store: users::Storage,\n     ) -> Self {\n         Self {\n             project_id,\n-            gb_repository,\n             project_store,\n+            local_data_dir,\n+            user_store,\n         }\n     }\n \n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/flush_session.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/flush_session.rs:36",
						"name": "Changed repository initialization from self.gb_repository to gb_repository::Repository.",
						"diff": "@@ -30,8 +36,15 @@ impl<'listener> Handler<'listener> {\n             .context(\"failed to get project\")?\n             .ok_or_else(|| anyhow!(\"project not found\"))?;\n \n-        let session = self\n-            .gb_repository\n+        let gb_repo = gb_repository::Repository::open(\n+            &self.local_data_dir,\n+            self.project_id.clone(),\n+            self.project_store.clone(),\n+            self.user_store.clone(),\n+        )\n+        .context(\"failed to open repository\")?;\n+\n+        let session = gb_repo\n             .flush_session(&project_repository::Repository::open(&project)?, session)\n             .context(\"failed to flush session\")?;\n \n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/flush_session.rs"
					}
				]
			},
			{
				"id": "watcher-work-w:src-tauri/src/watcher/handlers/git_file_change.rs",
				"path": "src-tauri/src/watcher/handlers/git_file_change.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/git_file_change.rs:4",
						"name": "Added `#[derive(Clone)]` to `Handler` struct.",
						"diff": "@@ -4,6 +4,7 @@ use crate::{project_repository, projects};\n \n use super::events;\n \n+#[derive(Clone)]\n pub struct Handler {\n     project_id: String,\n     project_store: projects::Storage,\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/git_file_change.rs"
					}
				]
			},
			{
				"id": "watcher-work-w:src-tauri/src/watcher/handlers/index_handler.rs",
				"path": "src-tauri/src/watcher/handlers/index_handler.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/index_handler.rs:1",
						"name": "Add paths, user and project stores to Handler struct.",
						"diff": "@@ -1,13 +1,21 @@\n+use std::path;\n+\n use anyhow::{Context, Result};\n \n-use crate::{bookmarks, deltas, events as app_events, files, gb_repository, search, sessions};\n+use crate::{\n+    bookmarks, deltas, events as app_events, files, gb_repository, projects, search, sessions,\n+    users,\n+};\n \n use super::events;\n \n-pub struct Handler<'handler> {\n+#[derive(Clone)]\n+pub struct Handler {\n+    local_data_dir: path::PathBuf,\n     project_id: String,\n+    project_store: projects::Storage,\n+    user_store: users::Storage,\n     deltas_searcher: search::Searcher,\n-    gb_repository: &'handler gb_repository::Repository,\n     files_database: files::Database,\n     sessions_database: sessions::Database,\n     deltas_database: deltas::Database,\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/index_handler.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/index_handler.rs:23",
						"name": "The diff updates the \"new\" function of struct Handler with more arguments.",
						"diff": "@@ -15,12 +23,14 @@ pub struct Handler<'handler> {\n     events_sender: app_events::Sender,\n }\n \n-impl<'handler> Handler<'handler> {\n+impl Handler {\n     #[allow(clippy::too_many_arguments)]\n     pub fn new(\n+        local_data_dir: path::PathBuf,\n         project_id: String,\n+        project_store: projects::Storage,\n+        user_store: users::Storage,\n         deltas_searcher: search::Searcher,\n-        gb_repository: &'handler gb_repository::Repository,\n         files_database: files::Database,\n         sessions_database: sessions::Database,\n         deltas_database: deltas::Database,\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/index_handler.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/index_handler.rs:38",
						"name": "Added local data directory and project and user stores to Handler struct.",
						"diff": "@@ -28,9 +38,11 @@ impl<'handler> Handler<'handler> {\n         events_sender: app_events::Sender,\n     ) -> Self {\n         Self {\n+            local_data_dir,\n             project_id,\n+            project_store,\n+            user_store,\n             deltas_searcher,\n-            gb_repository,\n             files_database,\n             sessions_database,\n             deltas_database,\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/index_handler.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/index_handler.rs:86",
						"name": "Code adds repository creation to reindex function",
						"diff": "@@ -74,7 +86,15 @@ impl<'handler> Handler<'handler> {\n     }\n \n     pub fn reindex(&self) -> Result<Vec<events::Event>> {\n-        let sessions_iter = self.gb_repository.get_sessions_iterator()?;\n+        let gb_repository = gb_repository::Repository::open(\n+            self.local_data_dir.clone(),\n+            self.project_id.clone(),\n+            self.project_store.clone(),\n+            self.user_store.clone(),\n+        )\n+        .context(\"failed to open repository\")?;\n+\n+        let sessions_iter = gb_repository.get_sessions_iterator()?;\n         let mut events = vec![];\n         for session in sessions_iter {\n             events.extend(self.index_session(&session?)?);\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/index_handler.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/index_handler.rs:103",
						"name": "Adds `gb_repository` variable and updates `self.deltas_searcher` call.",
						"diff": "@@ -83,16 +103,24 @@ impl<'handler> Handler<'handler> {\n     }\n \n     pub fn index_session(&self, session: &sessions::Session) -> Result<Vec<events::Event>> {\n+        let gb_repository = gb_repository::Repository::open(\n+            self.local_data_dir.clone(),\n+            self.project_id.clone(),\n+            self.project_store.clone(),\n+            self.user_store.clone(),\n+        )\n+        .context(\"failed to open repository\")?;\n+\n         // first of all, index session for searching. searhcer keeps it's own state to\n         // decide if the actual indexing needed\n         self.deltas_searcher\n-            .index_session(self.gb_repository, session)\n+            .index_session(&gb_repository, session)\n             .context(\"failed to index session\")?;\n \n         // index bookmarks right away. bookmarks are stored in the session during which it was\n         // created, not in the session that is actually bookmarked. so we want to make sure all of\n         // them are indexed at all times\n-        let session_reader = sessions::Reader::open(self.gb_repository, session)?;\n+        let session_reader = sessions::Reader::open(&gb_repository, session)?;\n         let bookmarks_reader = bookmarks::Reader::new(&session_reader);\n         for bookmark in bookmarks_reader.read()? {\n             self.index_bookmark(&bookmark)?;\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/index_handler.rs"
					}
				]
			},
			{
				"id": "watcher-work-w:src-tauri/src/watcher/handlers/mod.rs",
				"path": "src-tauri/src/watcher/handlers/mod.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/mod.rs:12",
						"name": "Added `use std::path::PathBuf;` and changed some struct handlers' lifetimes.",
						"diff": "@@ -12,35 +12,37 @@ mod check_current_session_tests;\n #[cfg(test)]\n mod project_file_change_tests;\n \n+use std::path::PathBuf;\n+\n use anyhow::{Context, Result};\n \n-use crate::{\n-    bookmarks, deltas, events as app_events, files, gb_repository, projects, search, sessions,\n-};\n+use crate::{bookmarks, deltas, events as app_events, files, projects, search, sessions, users};\n \n use super::events;\n \n-pub struct Handler<'handler> {\n+#[derive(Clone)]\n+pub struct Handler {\n     project_id: String,\n \n     file_change_handler: file_change::Handler,\n-    project_file_handler: project_file_change::Handler<'handler>,\n+    project_file_handler: project_file_change::Handler,\n     git_file_change_handler: git_file_change::Handler,\n-    check_current_session_handler: check_current_session::Handler<'handler>,\n-    flush_session_handler: flush_session::Handler<'handler>,\n-    fetch_project_handler: fetch_project::Handler<'handler>,\n+    check_current_session_handler: check_current_session::Handler,\n+    flush_session_handler: flush_session::Handler,\n+    fetch_project_handler: fetch_project::Handler,\n     chech_fetch_project_handler: check_fetch_project::Handler,\n-    index_handler: index_handler::Handler<'handler>,\n+    index_handler: index_handler::Handler,\n \n     events_sender: app_events::Sender,\n }\n \n-impl<'handler> Handler<'handler> {\n+impl<'handler> Handler {\n     #[allow(clippy::too_many_arguments)]\n     pub fn new(\n+        local_data_dir: PathBuf,\n         project_id: String,\n         project_store: projects::Storage,\n-        gb_repository: &'handler gb_repository::Repository,\n+        user_store: users::Storage,\n         searcher: search::Searcher,\n         events_sender: app_events::Sender,\n         sessions_database: sessions::Database,\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/mod.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/mod.rs:56",
						"name": "Added new arguments to project_file_handler and check_current_session_handler handlers.",
						"diff": "@@ -54,33 +56,43 @@ impl<'handler> Handler<'handler> {\n \n             file_change_handler: file_change::Handler::new(),\n             project_file_handler: project_file_change::Handler::new(\n+                local_data_dir.clone(),\n+                project_id.clone(),\n+                project_store.clone(),\n+                user_store.clone(),\n+            ),\n+            check_current_session_handler: check_current_session::Handler::new(\n+                local_data_dir.clone(),\n                 project_id.clone(),\n                 project_store.clone(),\n-                gb_repository,\n+                user_store.clone(),\n             ),\n-            check_current_session_handler: check_current_session::Handler::new(gb_repository),\n             git_file_change_handler: git_file_change::Handler::new(\n                 project_id.clone(),\n                 project_store.clone(),\n             ),\n             flush_session_handler: flush_session::Handler::new(\n+                local_data_dir.clone(),\n                 project_id.clone(),\n                 project_store.clone(),\n-                gb_repository,\n+                user_store.clone(),\n             ),\n             fetch_project_handler: fetch_project::Handler::new(\n+                local_data_dir.clone(),\n                 project_id.clone(),\n                 project_store.clone(),\n-                gb_repository,\n+                user_store.clone(),\n             ),\n             chech_fetch_project_handler: check_fetch_project::Handler::new(\n                 project_id.clone(),\n-                project_store,\n+                project_store.clone(),\n             ),\n             index_handler: index_handler::Handler::new(\n+                local_data_dir,\n                 project_id,\n+                project_store,\n+                user_store,\n                 searcher,\n-                gb_repository,\n                 files_database,\n                 sessions_database,\n                 deltas_database,\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/mod.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/mod.rs:102",
						"name": "Change function signature for handle() from synchronous to asynchronous.",
						"diff": "@@ -90,7 +102,7 @@ impl<'handler> Handler<'handler> {\n         }\n     }\n \n-    pub fn handle(&self, event: events::Event) -> Result<Vec<events::Event>> {\n+    pub async fn handle(&self, event: events::Event) -> Result<Vec<events::Event>> {\n         log::info!(\"{}: handling event: {}\", self.project_id, event);\n         match event {\n             events::Event::FileChange(path) => self\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/mod.rs"
					}
				]
			},
			{
				"id": "watcher-work-w:src-tauri/src/watcher/handlers/project_file_change.rs",
				"path": "src-tauri/src/watcher/handlers/project_file_change.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/project_file_change.rs:1",
						"name": "Added `user_store` and `local_data_dir` fields to `Handler` struct.",
						"diff": "@@ -1,31 +1,35 @@\n-use std::vec;\n+use std::{path, vec};\n \n use anyhow::{Context, Result};\n \n use crate::{\n     deltas, gb_repository, project_repository, projects,\n     reader::{self, Reader},\n-    sessions,\n+    sessions, users,\n };\n \n use super::events;\n \n-pub struct Handler<'listener> {\n+#[derive(Clone)]\n+pub struct Handler {\n     project_id: String,\n     project_store: projects::Storage,\n-    gb_repository: &'listener gb_repository::Repository,\n+    local_data_dir: path::PathBuf,\n+    user_store: users::Storage,\n }\n \n-impl<'listener> Handler<'listener> {\n+impl Handler {\n     pub fn new(\n+        local_data_dir: path::PathBuf,\n         project_id: String,\n         project_store: projects::Storage,\n-        gb_repository: &'listener gb_repository::Repository,\n+        user_store: users::Storage,\n     ) -> Self {\n         Self {\n             project_id,\n             project_store,\n-            gb_repository,\n+            local_data_dir,\n+            user_store,\n         }\n     }\n \n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/project_file_change.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/project_file_change.rs:66",
						"name": "Adds a new GitBlit repository in `get_current_deltas` method.",
						"diff": "@@ -62,12 +66,20 @@ impl<'listener> Handler<'listener> {\n \n     // returns deltas for the file that are already part of the current session (if any)\n     fn get_current_deltas(&self, path: &std::path::Path) -> Result<Option<Vec<deltas::Delta>>> {\n-        let current_session = self.gb_repository.get_current_session()?;\n+        let gb_repo = gb_repository::Repository::open(\n+            self.local_data_dir.clone(),\n+            self.project_id.clone(),\n+            self.project_store.clone(),\n+            self.user_store.clone(),\n+        )\n+        .context(\"failed to open gb repository\")?;\n+\n+        let current_session = gb_repo.get_current_session()?;\n         if current_session.is_none() {\n             return Ok(None);\n         }\n         let current_session = current_session.unwrap();\n-        let session_reader = sessions::Reader::open(self.gb_repository, &current_session)\n+        let session_reader = sessions::Reader::open(&gb_repo, &current_session)\n             .context(\"failed to get session reader\")?;\n         let deltas_reader = deltas::Reader::new(&session_reader);\n         let deltas = deltas_reader\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/project_file_change.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/project_file_change.rs:98",
						"name": "Adds opening `gb_repository` and updates condition for current session.",
						"diff": "@@ -86,9 +98,16 @@ impl<'listener> Handler<'listener> {\n         let project_repository = project_repository::Repository::open(&project)\n             .with_context(|| \"failed to open project repository for project\")?;\n \n+        let gb_repository = gb_repository::Repository::open(\n+            &self.local_data_dir,\n+            self.project_id.clone(),\n+            self.project_store.clone(),\n+            self.user_store.clone(),\n+        )\n+        .context(\"failed to open gb repository\")?;\n+\n         // If current session's branch is not the same as the project's head, flush it first.\n-        if let Some(session) = self\n-            .gb_repository\n+        if let Some(session) = gb_repository\n             .get_current_session()\n             .context(\"failed to get current session\")?\n         {\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/project_file_change.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/project_file_change.rs:115",
						"name": "Changed reference to an object within the same repository.",
						"diff": "@@ -96,7 +115,7 @@ impl<'listener> Handler<'listener> {\n                 .get_head()\n                 .context(\"failed to get head\")?;\n             if session.meta.branch != project_head.name().map(|s| s.to_string()) {\n-                self.gb_repository\n+                gb_repository\n                     .flush_session(&project_repository, &session)\n                     .context(\"failed to flush session\")?;\n             }\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/project_file_change.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/project_file_change.rs:131",
						"name": "Updated how `sessions::Reader` is opened using `gb_repository`.",
						"diff": "@@ -112,11 +131,10 @@ impl<'listener> Handler<'listener> {\n             None => return Ok(vec![]),\n         };\n \n-        let current_session = self\n-            .gb_repository\n+        let current_session = gb_repository\n             .get_or_create_current_session()\n             .context(\"failed to get or create current session\")?;\n-        let reader = sessions::Reader::open(self.gb_repository, &current_session)\n+        let reader = sessions::Reader::open(&gb_repository, &current_session)\n             .context(\"failed to get session reader\")?;\n \n         let latest_file_content = match reader.file(path) {\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/project_file_change.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/project_file_change.rs:173",
						"name": "Changed the creation of 'deltas::Writer' to use a reference to 'gb_repository'.",
						"diff": "@@ -155,7 +173,7 @@ impl<'listener> Handler<'listener> {\n         }\n \n         let deltas = text_doc.get_deltas();\n-        let writer = deltas::Writer::new(self.gb_repository)?;\n+        let writer = deltas::Writer::new(&gb_repository)?;\n         writer\n             .write(path, &deltas)\n             .with_context(|| \"failed to write deltas\")?;\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/project_file_change.rs"
					}
				]
			},
			{
				"id": "watcher-work-w:src-tauri/src/watcher/handlers/project_file_change_tests.rs",
				"path": "src-tauri/src/watcher/handlers/project_file_change_tests.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/project_file_change_tests.rs:68",
						"name": "Changes made to the `Handler` initialization and parameters.",
						"diff": "@@ -68,12 +68,17 @@ fn test_register_existing_commited_file() -> Result<()> {\n     commit_all(&repository)?;\n \n     let gb_repo = gb_repository::Repository::open(\n-        gb_repo_path,\n+        gb_repo_path.clone(),\n         project.id.clone(),\n         project_store.clone(),\n-        user_store,\n+        user_store.clone(),\n     )?;\n-    let listener = Handler::new(project.id.clone(), project_store, &gb_repo);\n+    let listener = Handler::new(\n+        gb_repo_path.into(),\n+        project.id.clone(),\n+        project_store,\n+        user_store,\n+    );\n \n     std::fs::write(project_repo.root().join(file_path), \"test2\")?;\n     listener.handle(file_path)?;\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/project_file_change_tests.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/project_file_change_tests.rs:112",
						"name": "The git diff hunk updates a listener handler in a Rust test.",
						"diff": "@@ -107,12 +112,17 @@ fn test_register_must_init_current_session() -> Result<()> {\n     let project_store = projects::Storage::new(storage);\n     project_store.add_project(&project)?;\n     let gb_repo = gb_repository::Repository::open(\n-        gb_repo_path,\n+        gb_repo_path.clone(),\n         project.id.clone(),\n         project_store.clone(),\n-        user_store,\n+        user_store.clone(),\n     )?;\n-    let listener = Handler::new(project.id.clone(), project_store, &gb_repo);\n+    let listener = Handler::new(\n+        gb_repo_path.into(),\n+        project.id.clone(),\n+        project_store,\n+        user_store,\n+    );\n \n     let file_path = std::path::Path::new(\"test.txt\");\n     std::fs::write(project_repo.root().join(file_path), \"test\")?;\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/project_file_change_tests.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/project_file_change_tests.rs:145",
						"name": "Changes the arguments of `Handler::new()`, adds `gb_repo_path.into()` as an argument.",
						"diff": "@@ -135,12 +145,17 @@ fn test_register_must_not_override_current_session() -> Result<()> {\n     let project_store = projects::Storage::new(storage);\n     project_store.add_project(&project)?;\n     let gb_repo = gb_repository::Repository::open(\n-        gb_repo_path,\n+        gb_repo_path.clone(),\n         project.id.clone(),\n         project_store.clone(),\n-        user_store,\n+        user_store.clone(),\n     )?;\n-    let listener = Handler::new(project.id.clone(), project_store, &gb_repo);\n+    let listener = Handler::new(\n+        gb_repo_path.into(),\n+        project.id.clone(),\n+        project_store,\n+        user_store,\n+    );\n \n     let file_path = std::path::Path::new(\"test.txt\");\n     std::fs::write(project_repo.root().join(file_path), \"test\")?;\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/project_file_change_tests.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/project_file_change_tests.rs:183",
						"name": "Changes made to the `Handler` initialization in `test_register_new_file()` function.",
						"diff": "@@ -168,12 +183,17 @@ fn test_register_new_file() -> Result<()> {\n     let project_store = projects::Storage::new(storage);\n     project_store.add_project(&project)?;\n     let gb_repo = gb_repository::Repository::open(\n-        gb_repo_path,\n+        gb_repo_path.clone(),\n         project.id.clone(),\n         project_store.clone(),\n-        user_store,\n+        user_store.clone(),\n     )?;\n-    let listener = Handler::new(project.id.clone(), project_store, &gb_repo);\n+    let listener = Handler::new(\n+        gb_repo_path.into(),\n+        project.id.clone(),\n+        project_store,\n+        user_store,\n+    );\n \n     let file_path = std::path::Path::new(\"test.txt\");\n     std::fs::write(project_repo.root().join(file_path), \"test\")?;\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/project_file_change_tests.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/project_file_change_tests.rs:229",
						"name": "The code adds a clone method to Repository::open and updates some parameters in Handler::new.",
						"diff": "@@ -209,12 +229,17 @@ fn test_register_new_file_twice() -> Result<()> {\n     let project_store = projects::Storage::new(storage);\n     project_store.add_project(&project)?;\n     let gb_repo = gb_repository::Repository::open(\n-        gb_repo_path,\n+        gb_repo_path.clone(),\n         project.id.clone(),\n         project_store.clone(),\n-        user_store,\n+        user_store.clone(),\n     )?;\n-    let listener = Handler::new(project.id.clone(), project_store, &gb_repo);\n+    let listener = Handler::new(\n+        gb_repo_path.into(),\n+        project.id.clone(),\n+        project_store,\n+        user_store,\n+    );\n \n     let file_path = std::path::Path::new(\"test.txt\");\n     std::fs::write(project_repo.root().join(file_path), \"test\")?;\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/project_file_change_tests.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/project_file_change_tests.rs:294",
						"name": "The code changes the `Handler` initialization for `gb_repo_path`.",
						"diff": "@@ -269,12 +294,17 @@ fn test_register_file_delted() -> Result<()> {\n     let project_store = projects::Storage::new(storage);\n     project_store.add_project(&project)?;\n     let gb_repo = gb_repository::Repository::open(\n-        gb_repo_path,\n+        gb_repo_path.clone(),\n         project.id.clone(),\n         project_store.clone(),\n-        user_store,\n+        user_store.clone(),\n     )?;\n-    let listener = Handler::new(project.id.clone(), project_store, &gb_repo);\n+    let listener = Handler::new(\n+        gb_repo_path.into(),\n+        project.id.clone(),\n+        project_store,\n+        user_store,\n+    );\n \n     let file_path = std::path::Path::new(\"test.txt\");\n     std::fs::write(project_repo.root().join(file_path), \"test\")?;\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/project_file_change_tests.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/project_file_change_tests.rs:351",
						"name": "Changed arguments for `Handler::new()` function.",
						"diff": "@@ -321,12 +351,17 @@ fn test_flow_with_commits() -> Result<()> {\n     let project_store = projects::Storage::new(storage);\n     project_store.add_project(&project)?;\n     let gb_repo = gb_repository::Repository::open(\n-        gb_repo_path,\n+        gb_repo_path.clone(),\n         project.id.clone(),\n         project_store.clone(),\n-        user_store,\n+        user_store.clone(),\n     )?;\n-    let listener = Handler::new(project.id.clone(), project_store, &gb_repo);\n+    let listener = Handler::new(\n+        gb_repo_path.into(),\n+        project.id.clone(),\n+        project_store,\n+        user_store,\n+    );\n \n     let size = 10;\n     let relative_file_path = std::path::Path::new(\"one/two/test.txt\");\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/project_file_change_tests.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/project_file_change_tests.rs:448",
						"name": "The git diff adds a new argument to the `Handler::new` function call.",
						"diff": "@@ -413,12 +448,17 @@ fn test_flow_no_commits() -> Result<()> {\n     let project_store = projects::Storage::new(storage);\n     project_store.add_project(&project)?;\n     let gb_repo = gb_repository::Repository::open(\n-        gb_repo_path,\n+        gb_repo_path.clone(),\n         project.id.clone(),\n         project_store.clone(),\n-        user_store,\n+        user_store.clone(),\n     )?;\n-    let listener = Handler::new(project.id.clone(), project_store, &gb_repo);\n+    let listener = Handler::new(\n+        gb_repo_path.into(),\n+        project.id.clone(),\n+        project_store,\n+        user_store,\n+    );\n \n     let size = 10;\n     let relative_file_path = std::path::Path::new(\"one/two/test.txt\");\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/project_file_change_tests.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/handlers/project_file_change_tests.rs:544",
						"name": "The git diff adds cloning of a path and changes the parameters of Handler::new().",
						"diff": "@@ -504,12 +544,17 @@ fn test_flow_signle_session() -> Result<()> {\n     let project_store = projects::Storage::new(storage);\n     project_store.add_project(&project)?;\n     let gb_repo = gb_repository::Repository::open(\n-        gb_repo_path,\n+        gb_repo_path.clone(),\n         project.id.clone(),\n         project_store.clone(),\n-        user_store,\n+        user_store.clone(),\n     )?;\n-    let listener = Handler::new(project.id.clone(), project_store, &gb_repo);\n+    let listener = Handler::new(\n+        gb_repo_path.into(),\n+        project.id.clone(),\n+        project_store,\n+        user_store,\n+    );\n \n     let size = 10;\n     let relative_file_path = std::path::Path::new(\"one/two/test.txt\");\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/handlers/project_file_change_tests.rs"
					}
				]
			},
			{
				"id": "watcher-work-w:src-tauri/src/watcher/mod.rs",
				"path": "src-tauri/src/watcher/mod.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "watcher-work-w:src-tauri/src/watcher/mod.rs:2",
						"name": "Changed Watcher struct - added local_data_dir and removed gb_repository parameter",
						"diff": "@@ -2,27 +2,30 @@ mod dispatchers;\n mod events;\n mod handlers;\n \n+use std::path;\n+\n pub use events::Event;\n \n use anyhow::Result;\n use tokio::sync::mpsc;\n use tokio_util::sync::CancellationToken;\n \n-use crate::{bookmarks, deltas, files, gb_repository, projects, search, sessions};\n+use crate::{bookmarks, deltas, files, projects, search, sessions, users};\n \n-pub struct Watcher<'watcher> {\n+pub struct Watcher {\n     project_id: String,\n     dispatcher: dispatchers::Dispatcher,\n-    handler: handlers::Handler<'watcher>,\n+    handler: handlers::Handler,\n     cancellation_token: CancellationToken,\n }\n \n-impl<'watcher> Watcher<'watcher> {\n+impl<'watcher> Watcher {\n     #[allow(clippy::too_many_arguments)]\n     pub fn new(\n+        local_data_dir: path::PathBuf,\n         project: &projects::Project,\n         project_store: projects::Storage,\n-        gb_repository: &'watcher gb_repository::Repository,\n+        user_store: users::Storage,\n         deltas_searcher: search::Searcher,\n         cancellation_token: CancellationToken,\n         events_sender: crate::events::Sender,\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/mod.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/mod.rs:38",
						"name": "A new parameter, local_data_dir, was added to the Handler constructor.",
						"diff": "@@ -35,9 +38,10 @@ impl<'watcher> Watcher<'watcher> {\n             project_id: project.id.clone(),\n             dispatcher: dispatchers::Dispatcher::new(project.id.clone(), project.path.clone()),\n             handler: handlers::Handler::new(\n+                local_data_dir,\n                 project.id.clone(),\n                 project_store,\n-                gb_repository,\n+                user_store,\n                 deltas_searcher,\n                 events_sender,\n                 sessions_database,\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/mod.rs"
					},
					{
						"id": "watcher-work-w:src-tauri/src/watcher/mod.rs:71",
						"name": "Changes to the implementation of event handling in `Watcher` struct.",
						"diff": "@@ -67,15 +71,22 @@ impl<'watcher> Watcher<'watcher> {\n                         log::error!(\"{}: failed to post event: {:#}\", self.project_id, e);\n                     }\n                 },\n-                Some(event) = events_rx.recv() => match self.handler.handle(event) {\n-                    Err(err) => log::error!(\"{}: failed to handle event: {:#}\", self.project_id, err),\n-                    Ok(events) => {\n-                        for event in events {\n-                            if let Err(e) = events_tx.send(event) {\n-                                log::error!(\"{}: failed to post event: {:#}\", self.project_id, e);\n-                            }\n+                Some(event) = events_rx.recv() => {\n+                    let project_id = self.project_id.clone();\n+                    let handler = self.handler.clone();\n+                    let events_tx = events_tx.clone();\n+                    tauri::async_runtime::spawn(async move {\n+                        match handler.handle(event).await {\n+                            Ok(events) => {\n+                                for event in events {\n+                                    if let Err(e) = events_tx.send(event) {\n+                                        log::error!(\"{}: failed to post event: {:#}\", project_id, e);\n+                                    }\n+                                }\n+                            },\n+                            Err(err) => log::error!(\"{}: failed to handle event: {:#}\", project_id, err),\n                         }\n-                    }\n+                    });\n                 },\n                 _ = self.cancellation_token.cancelled() => {\n                     if let Err(e) = self.dispatcher.stop() {\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-07T11:58:51Z",
						"filePath": "src-tauri/src/watcher/mod.rs"
					}
				]
			}
		],
		"description": "watcher handler run async\n"
	},
	{
		"id": "ian/cursor-for-select-text-from-diff:409",
		"name": "ian/cursor-for-select-text-from-diff",
		"active": true,
		"kind": "branch",
		"files": [
			{
				"id": "ian/cursor-for-select-text-from-diff:src/lib/components/Differ/Differ.svelte",
				"path": "src/lib/components/Differ/Differ.svelte",
				"kind": "file",
				"hunks": [
					{
						"id": "ian/cursor-for-select-text-from-diff:src/lib/components/Differ/Differ.svelte:236",
						"name": "Cursor-text class added to span in line 236.",
						"diff": "@@ -236,7 +236,7 @@\n \t\t</span>\n \n \t\t<span\n-\t\t\tclass=\"diff-line-{row.type} overflow-hidden whitespace-pre-wrap\"\n+\t\t\tclass=\"diff-line-{row.type} cursor-text overflow-hidden whitespace-pre-wrap\"\n \t\t\tclass:line-changed={row.type === RowType.Addition || row.type === RowType.Deletion}\n \t\t>\n \t\t\t{#each row.render.html as content}\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-06T12:42:02Z",
						"filePath": "src/lib/components/Differ/Differ.svelte"
					}
				]
			}
		],
		"description": "Ian/cursor for select text from diff\n"
	},
	{
		"id": "writers:407",
		"name": "writers",
		"active": true,
		"kind": "branch",
		"files": [
			{
				"id": "writers:src-tauri/src/app.rs",
				"path": "src-tauri/src/app.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "writers:src-tauri/src/app.rs:287",
						"name": "Replaced session writer with bookmarks writer for adding bookmark in App.",
						"diff": "@@ -287,17 +287,9 @@ impl App {\n         )\n         .context(\"failed to open repository\")?;\n \n-        let session = gb_repository\n-            .get_or_create_current_session()\n-            .context(\"failed to get or create current session\")?;\n-        let writer = sessions::Writer::open(&gb_repository, &session)\n-            .context(\"failed to open session writer\")?;\n-        writer\n-            .write_bookmark(bookmark)\n-            .context(\"failed to write bookmark\")?;\n-        // let updated = self.bookmarks_database.upsert(bookmark).context(\"failed to upsert bookmark\")?;\n-\n-        // if let Some(updated) = updated.as_ref() {\n+        let writer = bookmarks::Writer::new(&gb_repository).context(\"failed to open writer\")?;\n+        writer.write(bookmark).context(\"failed to write bookmark\")?;\n+\n         if let Err(e) = self\n             .proxy_watchers\n             .lock()\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/app.rs"
					},
					{
						"id": "writers:src-tauri/src/app.rs:301",
						"name": "Removed commented out code in `impl App` method",
						"diff": "@@ -309,9 +301,6 @@ impl App {\n             log::error!(\"failed to send session event: {:#}\", e);\n         }\n         Ok(())\n-        // }\n-\n-        // Ok(updated)\n     }\n \n     pub fn list_bookmarks(\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/app.rs"
					},
					{
						"id": "writers:src-tauri/src/app.rs:485",
						"name": "App: Replaced session writer with pty writer for timestamp.",
						"diff": "@@ -496,10 +485,7 @@ impl App {\n         )\n         .context(\"failed to open repository\")?;\n \n-        let session = gb_repository\n-            .get_or_create_current_session()\n-            .context(\"failed to get session\")?;\n-        let writer = sessions::Writer::open(&gb_repository, &session)?;\n+        let pty_writer = pty::Writer::new(&gb_repository)?;\n \n         let timestamp = std::time::SystemTime::now()\n             .duration_since(std::time::UNIX_EPOCH)\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/app.rs"
					},
					{
						"id": "writers:src-tauri/src/app.rs:498",
						"name": "Changed method call from `writer.append_pty` to `pty_writer.write`.",
						"diff": "@@ -512,7 +498,7 @@ impl App {\n             bytes: bytes.to_vec(),\n         };\n \n-        writer.append_pty(&record).context(\"failed to append pty\")?;\n+        pty_writer.write(&record).context(\"failed to append pty\")?;\n \n         Ok(())\n     }\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/app.rs"
					}
				]
			},
			{
				"id": "writers:src-tauri/src/bookmarks/mod.rs",
				"path": "src-tauri/src/bookmarks/mod.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "writers:src-tauri/src/bookmarks/mod.rs:1",
						"name": "Added \"mod writer\" to the code.",
						"diff": "@@ -1,5 +1,6 @@\n mod database;\n mod reader;\n+mod writer;\n \n use serde::{Deserialize, Serialize};\n \n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/bookmarks/mod.rs"
					},
					{
						"id": "writers:src-tauri/src/bookmarks/mod.rs:17",
						"name": "Added BookmarksWriter as Writer to pub use.",
						"diff": "@@ -16,3 +17,4 @@ pub struct Bookmark {\n \n pub use database::Database;\n pub use reader::BookmarksReader as Reader;\n+pub use writer::BookmarksWriter as Writer;\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/bookmarks/mod.rs"
					}
				]
			},
			{
				"id": "writers:src-tauri/src/bookmarks/writer.rs",
				"path": "src-tauri/src/bookmarks/writer.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "writers:src-tauri/src/bookmarks/writer.rs:1",
						"name": "Adds a BookmarksWriter struct and methods for writing bookmarks to JSON.",
						"diff": "@@ -0,0 +1,38 @@\n+use anyhow::{Context, Result};\n+\n+use crate::gb_repository;\n+\n+use super::Bookmark;\n+\n+pub struct BookmarksWriter<'writer> {\n+    repository: &'writer gb_repository::Repository,\n+}\n+\n+impl<'writer> BookmarksWriter<'writer> {\n+    pub fn new(repository: &'writer gb_repository::Repository) -> Result<Self> {\n+        repository\n+            .get_or_create_current_session()\n+            .context(\"failed to create session\")?;\n+        Ok(Self { repository })\n+    }\n+\n+    pub fn write(&self, bookmark: &Bookmark) -> Result<()> {\n+        self.repository.lock()?;\n+        defer! {\n+            self.repository.unlock().expect(\"failed to unlock\");\n+        }\n+\n+        serde_jsonlines::append_json_lines(\n+            self.repository.session_path().join(\"bookmarks.jsonl\"),\n+            [bookmark],\n+        )?;\n+\n+        log::info!(\n+            \"{}: wrote bookmark {}\",\n+            self.repository.project_id,\n+            bookmark.timestamp_ms\n+        );\n+\n+        Ok(())\n+    }\n+}\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/bookmarks/writer.rs"
					}
				]
			},
			{
				"id": "writers:src-tauri/src/deltas/mod.rs",
				"path": "src-tauri/src/deltas/mod.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "writers:src-tauri/src/deltas/mod.rs:3",
						"name": "Added \"mod writer\" and \"pub use writer::DeltasWriter\".",
						"diff": "@@ -3,9 +3,11 @@ mod delta;\n mod document;\n mod operations;\n mod reader;\n+mod writer;\n \n pub use database::Database;\n pub use delta::Delta;\n pub use document::Document;\n pub use operations::Operation;\n pub use reader::DeltasReader as Reader;\n+pub use writer::DeltasWriter as Writer;\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/deltas/mod.rs"
					}
				]
			},
			{
				"id": "writers:src-tauri/src/deltas/writer.rs",
				"path": "src-tauri/src/deltas/writer.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "writers:src-tauri/src/deltas/writer.rs:1",
						"name": "Added a struct and its implementation to write delta files.",
						"diff": "@@ -0,0 +1,71 @@\n+use anyhow::{Context, Result};\n+\n+use crate::{\n+    gb_repository,\n+    writer::{self, Writer},\n+};\n+\n+use super::Delta;\n+\n+pub struct DeltasWriter<'writer> {\n+    repository: &'writer gb_repository::Repository,\n+    writer: writer::DirWriter,\n+}\n+\n+impl<'writer> DeltasWriter<'writer> {\n+    pub fn new(repository: &'writer gb_repository::Repository) -> Result<Self> {\n+        let writer = writer::DirWriter::open(repository.root());\n+        repository\n+            .get_or_create_current_session()\n+            .context(\"failed to create session\")?;\n+        Ok(Self { writer, repository })\n+    }\n+\n+    pub fn write<P: AsRef<std::path::Path>>(&self, path: P, deltas: &Vec<Delta>) -> Result<()> {\n+        self.repository.lock()?;\n+        defer! {\n+            self.repository.unlock().unwrap();\n+        }\n+\n+        let path = path.as_ref();\n+        let raw_deltas = serde_json::to_string(&deltas)?;\n+\n+        self.writer.write_string(\n+            self.repository.deltas_path().join(path).to_str().unwrap(),\n+            &raw_deltas,\n+        )?;\n+\n+        log::info!(\n+            \"{}: wrote deltas for {}\",\n+            self.repository.project_id,\n+            path.display()\n+        );\n+\n+        Ok(())\n+    }\n+\n+    pub fn write_wd_file<P: AsRef<std::path::Path>>(&self, path: P, contents: &str) -> Result<()> {\n+        self.repository.lock()?;\n+        defer! {\n+            self.repository.unlock().expect(\"failed to unlock\");\n+        }\n+\n+        let path = path.as_ref();\n+        self.writer.write_string(\n+            self.repository\n+                .session_wd_path()\n+                .join(path)\n+                .to_str()\n+                .unwrap(),\n+            contents,\n+        )?;\n+\n+        log::info!(\n+            \"{}: wrote session wd file {}\",\n+            self.repository.project_id,\n+            path.display()\n+        );\n+\n+        Ok(())\n+    }\n+}\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/deltas/writer.rs"
					}
				]
			},
			{
				"id": "writers:src-tauri/src/gb_repository/repository.rs",
				"path": "src-tauri/src/gb_repository/repository.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "writers:src-tauri/src/gb_repository/repository.rs:280",
						"name": "Changed method call for writing session to disk in Repository implementation.",
						"diff": "@@ -280,7 +280,7 @@ impl Repository {\n         };\n \n         // write session to disk\n-        sessions::Writer::open(self, &session)?;\n+        sessions::Writer::new(self).write(&session)?;\n \n         Ok(session)\n     }\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/gb_repository/repository.rs"
					},
					{
						"id": "writers:src-tauri/src/gb_repository/repository.rs:363",
						"name": "The git diff updates a timestamp without opening a session writer.",
						"diff": "@@ -363,8 +363,8 @@ impl Repository {\n             return Err(anyhow!(\"nothing to flush\"));\n         }\n \n-        // touch session writer to update last timestamp\n-        sessions::Writer::open(self, session)?;\n+        // update last timestamp\n+        sessions::Writer::new(self).write(session)?;\n \n         self.lock()?;\n         defer! {\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/gb_repository/repository.rs"
					}
				]
			},
			{
				"id": "writers:src-tauri/src/gb_repository/repository_tests.rs",
				"path": "src-tauri/src/gb_repository/repository_tests.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "writers:src-tauri/src/gb_repository/repository_tests.rs:1",
						"name": "A Rust code changed import order and removed a function call.",
						"diff": "@@ -1,10 +1,9 @@\n use std::{thread, time};\n \n+use crate::{deltas, gb_repository, projects, sessions, storage, users};\n use anyhow::Result;\n use tempfile::tempdir;\n \n-use crate::{deltas, gb_repository, projects, sessions, storage, users};\n-\n fn remote_repository() -> Result<git2::Repository> {\n     let path = tempdir()?.path().to_str().unwrap().to_string();\n     let repository = git2::Repository::init_bare(path)?;\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/gb_repository/repository_tests.rs"
					},
					{
						"id": "writers:src-tauri/src/gb_repository/repository_tests.rs:199",
						"name": "In a Git repository, changes to file \"test.txt\" are written using a new \"deltas Writer\" instead of the old \"sessions Writer\".",
						"diff": "@@ -200,8 +199,8 @@ fn test_list_deltas_from_current_session() -> Result<()> {\n         gb_repository::Repository::open(gb_repo_path, project.id, project_store, user_store)?;\n \n     let current_session = gb_repo.get_or_create_current_session()?;\n-    let writer = sessions::Writer::open(&gb_repo, &current_session)?;\n-    writer.write_deltas(\n+    let writer = deltas::Writer::new(&gb_repo)?;\n+    writer.write(\n         \"test.txt\",\n         &vec![deltas::Delta {\n             operations: vec![deltas::Operation::Insert((0, \"Hello World\".to_string()))],\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/gb_repository/repository_tests.rs"
					},
					{
						"id": "writers:src-tauri/src/gb_repository/repository_tests.rs:234",
						"name": "Changed writer from sessions to deltas in test case for writing deltas in git repo.",
						"diff": "@@ -235,9 +234,8 @@ fn test_list_deltas_from_flushed_session() -> Result<()> {\n     let gb_repo =\n         gb_repository::Repository::open(gb_repo_path, project.id, project_store, user_store)?;\n \n-    let current_session = gb_repo.get_or_create_current_session()?;\n-    let writer = sessions::Writer::open(&gb_repo, &current_session)?;\n-    writer.write_deltas(\n+    let writer = deltas::Writer::new(&gb_repo)?;\n+    writer.write(\n         \"test.txt\",\n         &vec![deltas::Delta {\n             operations: vec![deltas::Operation::Insert((0, \"Hello World\".to_string()))],\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/gb_repository/repository_tests.rs"
					},
					{
						"id": "writers:src-tauri/src/gb_repository/repository_tests.rs:360",
						"name": "Changed code to use \"deltas\" module for writing test.txt in test_remote_syncronization function.",
						"diff": "@@ -362,9 +360,8 @@ fn test_remote_syncronization() -> Result<()> {\n         project_store.clone(),\n         user_store.clone(),\n     )?;\n-    let session_one = gb_repo_one.get_or_create_current_session()?;\n-    let writer = sessions::Writer::open(&gb_repo_one, &session_one)?;\n-    writer.write_deltas(\n+    let writer = deltas::Writer::new(&gb_repo_one)?;\n+    writer.write(\n         \"test.txt\",\n         &vec![deltas::Delta {\n             operations: vec![deltas::Operation::Insert((0, \"Hello World\".to_string()))],\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/gb_repository/repository_tests.rs"
					}
				]
			},
			{
				"id": "writers:src-tauri/src/pty/mod.rs",
				"path": "src-tauri/src/pty/mod.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "writers:src-tauri/src/pty/mod.rs:1",
						"name": "Added \"mod writer\" and \"pub use writer::PtyWriter as Writer\".",
						"diff": "@@ -1,6 +1,8 @@\n mod connection;\n mod recorder;\n mod server;\n+mod writer;\n \n pub use recorder::{Record, Type};\n pub use server::start_server;\n+pub use writer::PtyWriter as Writer;\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/pty/mod.rs"
					}
				]
			},
			{
				"id": "writers:src-tauri/src/pty/writer.rs",
				"path": "src-tauri/src/pty/writer.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "writers:src-tauri/src/pty/writer.rs:1",
						"name": "Adds a struct for writing to a Pty and its implementation.",
						"diff": "@@ -0,0 +1,37 @@\n+use anyhow::{Context, Result};\n+\n+use crate::gb_repository;\n+\n+use super::Record;\n+\n+pub struct PtyWriter<'writer> {\n+    repository: &'writer gb_repository::Repository,\n+}\n+\n+impl<'writer> PtyWriter<'writer> {\n+    pub fn new(repository: &'writer gb_repository::Repository) -> Result<Self> {\n+        repository\n+            .get_or_create_current_session()\n+            .context(\"failed to create session\")?;\n+        Ok(Self { repository })\n+    }\n+\n+    pub fn write(&self, record: &Record) -> Result<()> {\n+        self.repository.lock()?;\n+        defer! {\n+            self.repository.unlock().expect(\"failed to unlock\");\n+        }\n+\n+        serde_jsonlines::append_json_lines(\n+            self.repository.session_path().join(\"pty.jsonl\"),\n+            [record],\n+        )?;\n+\n+        log::info!(\n+            \"{}: appended pty record to session\",\n+            self.repository.project_id\n+        );\n+\n+        Ok(())\n+    }\n+}\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/pty/writer.rs"
					}
				]
			},
			{
				"id": "writers:src-tauri/src/search/searcher_test.rs",
				"path": "src-tauri/src/search/searcher_test.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "writers:src-tauri/src/search/searcher_test.rs:3",
						"name": "Removed sessions module from crate import list.",
						"diff": "@@ -3,7 +3,7 @@ use std::{path::Path, time};\n use anyhow::Result;\n use tempfile::tempdir;\n \n-use crate::{bookmarks, deltas, gb_repository, projects, sessions, storage, users};\n+use crate::{bookmarks, deltas, gb_repository, projects, storage, users};\n \n fn test_repository() -> Result<git2::Repository> {\n     let path = tempdir()?.path().to_str().unwrap().to_string();\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/search/searcher_test.rs"
					},
					{
						"id": "writers:src-tauri/src/search/searcher_test.rs:49",
						"name": "Changed writer from session-based to delta-based at line 52.",
						"diff": "@@ -49,9 +49,8 @@ fn test_sorted_by_timestamp() -> Result<()> {\n \n     let index_path = tempdir()?.path().to_str().unwrap().to_string();\n \n-    let session = gb_repo.get_or_create_current_session()?;\n-    let writer = sessions::Writer::open(&gb_repo, &session)?;\n-    writer.write_deltas(\n+    let writer = deltas::Writer::new(&gb_repo)?;\n+    writer.write(\n         Path::new(\"test.txt\"),\n         &vec![\n             deltas::Delta {\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/search/searcher_test.rs"
					},
					{
						"id": "writers:src-tauri/src/search/searcher_test.rs:99",
						"name": "Update function to use new delta writer in Git repo.",
						"diff": "@@ -100,9 +99,8 @@ fn search_by_bookmark_note() -> Result<()> {\n \n     let index_path = tempdir()?.path().to_str().unwrap().to_string();\n \n-    let session = gb_repo.get_or_create_current_session()?;\n-    let writer = sessions::Writer::open(&gb_repo, &session)?;\n-    writer.write_deltas(\n+    let writer = deltas::Writer::new(&gb_repo)?;\n+    writer.write(\n         Path::new(\"test.txt\"),\n         &vec![deltas::Delta {\n             operations: vec![deltas::Operation::Insert((0, \"Hello\".to_string()))],\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/search/searcher_test.rs"
					},
					{
						"id": "writers:src-tauri/src/search/searcher_test.rs:195",
						"name": "Updates the writer from using sessions to deltas.",
						"diff": "@@ -197,9 +195,8 @@ fn search_by_full_match() -> Result<()> {\n \n     let index_path = tempdir()?.path().to_str().unwrap().to_string();\n \n-    let session = gb_repo.get_or_create_current_session()?;\n-    let writer = sessions::Writer::open(&gb_repo, &session)?;\n-    writer.write_deltas(\n+    let writer = deltas::Writer::new(&gb_repo)?;\n+    writer.write(\n         Path::new(\"test.txt\"),\n         &vec![deltas::Delta {\n             operations: vec![deltas::Operation::Insert((0, \"hello\".to_string()))],\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/search/searcher_test.rs"
					},
					{
						"id": "writers:src-tauri/src/search/searcher_test.rs:236",
						"name": "Git diff removes session creation and replaces writer method in search function.",
						"diff": "@@ -239,9 +236,8 @@ fn search_by_diff() -> Result<()> {\n \n     let index_path = tempdir()?.path().to_str().unwrap().to_string();\n \n-    let session = gb_repo.get_or_create_current_session()?;\n-    let writer = sessions::Writer::open(&gb_repo, &session)?;\n-    writer.write_deltas(\n+    let writer = deltas::Writer::new(&gb_repo)?;\n+    writer.write(\n         Path::new(\"test.txt\"),\n         &vec![\n             deltas::Delta {\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/search/searcher_test.rs"
					},
					{
						"id": "writers:src-tauri/src/search/searcher_test.rs:355",
						"name": "Changed \"get_or_create_current_session\" to \"new\" for \"deltas::Writer\"",
						"diff": "@@ -359,9 +355,8 @@ fn test_delete_all() -> Result<()> {\n \n     let index_path = tempdir()?.path().to_str().unwrap().to_string();\n \n-    let session = gb_repo.get_or_create_current_session()?;\n-    let writer = sessions::Writer::open(&gb_repo, &session)?;\n-    writer.write_deltas(\n+    let writer = deltas::Writer::new(&gb_repo)?;\n+    writer.write(\n         Path::new(\"test.txt\"),\n         &vec![\n             deltas::Delta {\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/search/searcher_test.rs"
					},
					{
						"id": "writers:src-tauri/src/search/searcher_test.rs:404",
						"name": "Modifies code for finding bookmarks: changes session writer to delta writer.",
						"diff": "@@ -409,9 +404,8 @@ fn search_bookmark_by_phrase() -> Result<()> {\n \n     let index_path = tempdir()?.path().to_str().unwrap().to_string();\n \n-    let session = gb_repo.get_or_create_current_session()?;\n-    let writer = sessions::Writer::open(&gb_repo, &session)?;\n-    writer.write_deltas(\n+    let writer = deltas::Writer::new(&gb_repo)?;\n+    writer.write(\n         Path::new(\"test.txt\"),\n         &vec![deltas::Delta {\n             operations: vec![deltas::Operation::Insert((0, \"Hello\".to_string()))],\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/search/searcher_test.rs"
					},
					{
						"id": "writers:src-tauri/src/search/searcher_test.rs:460",
						"name": "The git diff hunk changes the method of writing deltas in search_by_filename function.",
						"diff": "@@ -466,9 +460,8 @@ fn search_by_filename() -> Result<()> {\n \n     let index_path = tempdir()?.path().to_str().unwrap().to_string();\n \n-    let session = gb_repo.get_or_create_current_session()?;\n-    let writer = sessions::Writer::open(&gb_repo, &session)?;\n-    writer.write_deltas(\n+    let writer = deltas::Writer::new(&gb_repo)?;\n+    writer.write(\n         Path::new(\"test.txt\"),\n         &vec![\n             deltas::Delta {\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/search/searcher_test.rs"
					}
				]
			},
			{
				"id": "writers:src-tauri/src/sessions/tests.rs",
				"path": "src-tauri/src/sessions/tests.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "writers:src-tauri/src/sessions/tests.rs:58",
						"name": "Changed assertion to use new Writer method instead of open.",
						"diff": "@@ -58,7 +58,7 @@ fn test_should_not_write_session_with_hash() -> Result<()> {\n         },\n     };\n \n-    assert!(Writer::open(&gb_repo, &session).is_err());\n+    assert!(Writer::new(&gb_repo).write(&session).is_err());\n \n     Ok(())\n }\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/sessions/tests.rs"
					},
					{
						"id": "writers:src-tauri/src/sessions/tests.rs:86",
						"name": "The code changes Writer::open to Writer::new for writing sessions.",
						"diff": "@@ -86,7 +86,7 @@ fn test_should_write_full_session() -> Result<()> {\n         },\n     };\n \n-    Writer::open(&gb_repo, &session)?;\n+    Writer::new(&gb_repo).write(&session)?;\n \n     assert_eq!(\n         std::fs::read_to_string(gb_repo.session_path().join(\"meta/id\"))?,\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/sessions/tests.rs"
					},
					{
						"id": "writers:src-tauri/src/sessions/tests.rs:135",
						"name": "The code updates Writer method to use write() instead of open().",
						"diff": "@@ -135,7 +135,7 @@ fn test_should_write_partial_session() -> Result<()> {\n         },\n     };\n \n-    Writer::open(&gb_repo, &session)?;\n+    Writer::new(&gb_repo).write(&session)?;\n \n     assert_eq!(\n         std::fs::read_to_string(gb_repo.session_path().join(\"meta/id\"))?,\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/sessions/tests.rs"
					}
				]
			},
			{
				"id": "writers:src-tauri/src/sessions/writer.rs",
				"path": "src-tauri/src/sessions/writer.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "writers:src-tauri/src/sessions/writer.rs:3",
						"name": "Remove unused imports and modules.",
						"diff": "@@ -3,7 +3,7 @@ use std::time;\n use anyhow::{anyhow, Context, Result};\n \n use crate::{\n-    bookmarks, deltas, gb_repository, pty,\n+    gb_repository,\n     reader::{self, Reader},\n     writer::{self, Writer},\n };\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/sessions/writer.rs"
					},
					{
						"id": "writers:src-tauri/src/sessions/writer.rs:16",
						"name": "Added new `new` method and modified `open` method in `SessionWriter` struct.",
						"diff": "@@ -16,20 +16,25 @@ pub struct SessionWriter<'writer> {\n }\n \n impl<'writer> SessionWriter<'writer> {\n-    pub fn open(repository: &'writer gb_repository::Repository, session: &Session) -> Result<Self> {\n+    pub fn new(repository: &'writer gb_repository::Repository) -> Self {\n+        let writer = writer::DirWriter::open(repository.root());\n+        SessionWriter { repository, writer }\n+    }\n+\n+    pub fn write(&self, session: &Session) -> Result<()> {\n         if session.hash.is_some() {\n             return Err(anyhow!(\"can not open writer for a session with a hash\"));\n         }\n \n-        repository.lock()?;\n+        self.repository.lock()?;\n         defer! {\n-            repository.unlock().expect(\"failed to unlock\");\n+            self.repository.unlock().expect(\"failed to unlock\");\n         }\n \n-        let reader = reader::DirReader::open(repository.root());\n+        let reader = reader::DirReader::open(self.repository.root());\n \n         let current_session_id = reader.read_to_string(\n-            repository\n+            self.repository\n                 .session_path()\n                 .join(\"meta\")\n                 .join(\"id\")\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/sessions/writer.rs"
					},
					{
						"id": "writers:src-tauri/src/sessions/writer.rs:45",
						"name": "Refactors code to use 'self' instead of 'repository' and 'writer'.",
						"diff": "@@ -40,17 +45,15 @@ impl<'writer> SessionWriter<'writer> {\n         if current_session_id.is_ok() && !current_session_id.as_ref().unwrap().eq(&session.id) {\n             return Err(anyhow!(\n                 \"{}: can not open writer for {} because a writer for {} is still open\",\n-                repository.project_id,\n+                self.repository.project_id,\n                 session.id,\n                 current_session_id.unwrap()\n             ));\n         }\n \n-        let writer = writer::DirWriter::open(repository.root());\n-\n-        writer\n+        self.writer\n             .write_string(\n-                repository\n+                self.repository\n                     .session_path()\n                     .join(\"meta\")\n                     .join(\"last\")\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/sessions/writer.rs"
					},
					{
						"id": "writers:src-tauri/src/sessions/writer.rs:69",
						"name": "Changes made to SessionWriter method to return Ok if current session ID equals session ID.",
						"diff": "@@ -66,13 +69,12 @@ impl<'writer> SessionWriter<'writer> {\n             .with_context(|| \"failed to write last timestamp\")?;\n \n         if current_session_id.is_ok() && current_session_id.as_ref().unwrap().eq(&session.id) {\n-            let writer = SessionWriter { repository, writer };\n-            return Ok(writer);\n+            return Ok(());\n         }\n \n-        writer\n+        self.writer\n             .write_string(\n-                repository\n+                self.repository\n                     .session_path()\n                     .join(\"meta\")\n                     .join(\"id\")\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/sessions/writer.rs"
					},
					{
						"id": "writers:src-tauri/src/sessions/writer.rs:84",
						"name": "Change writer to self.writer and repository to self.repository.",
						"diff": "@@ -82,9 +84,9 @@ impl<'writer> SessionWriter<'writer> {\n             )\n             .with_context(|| \"failed to write id\")?;\n \n-        writer\n+        self.writer\n             .write_string(\n-                repository\n+                self.repository\n                     .session_path()\n                     .join(\"meta\")\n                     .join(\"start\")\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/sessions/writer.rs"
					},
					{
						"id": "writers:src-tauri/src/sessions/writer.rs:97",
						"name": "Refactors writer to self.writer and repository to self.repository.",
						"diff": "@@ -95,9 +97,9 @@ impl<'writer> SessionWriter<'writer> {\n             .with_context(|| \"failed to write start timestamp\")?;\n \n         if let Some(branch) = session.meta.branch.as_ref() {\n-            writer\n+            self.writer\n                 .write_string(\n-                    repository\n+                    self.repository\n                         .session_path()\n                         .join(\"meta\")\n                         .join(\"branch\")\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/sessions/writer.rs"
					},
					{
						"id": "writers:src-tauri/src/sessions/writer.rs:111",
						"name": "Changed `writer` to `self.writer` and `repository` to `self.repository`.",
						"diff": "@@ -109,9 +111,9 @@ impl<'writer> SessionWriter<'writer> {\n         }\n \n         if let Some(commit) = session.meta.commit.as_ref() {\n-            writer\n+            self.writer\n                 .write_string(\n-                    repository\n+                    self.repository\n                         .session_path()\n                         .join(\"meta\")\n                         .join(\"commit\")\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/sessions/writer.rs"
					},
					{
						"id": "writers:src-tauri/src/sessions/writer.rs:124",
						"name": "Removed two functions and their implementation.",
						"diff": "@@ -122,104 +124,6 @@ impl<'writer> SessionWriter<'writer> {\n                 .with_context(|| \"failed to write commit\")?;\n         }\n \n-        let writer = SessionWriter { repository, writer };\n-\n-        Ok(writer)\n-    }\n-\n-    pub fn append_pty(&self, record: &pty::Record) -> Result<()> {\n-        self.repository.lock()?;\n-        defer! {\n-            self.repository.unlock().expect(\"failed to unlock\");\n-        }\n-\n-        serde_jsonlines::append_json_lines(\n-            self.repository.session_path().join(\"pty.jsonl\"),\n-            [record],\n-        )?;\n-\n-        log::info!(\n-            \"{}: appended pty record to session\",\n-            self.repository.project_id\n-        );\n-\n-        Ok(())\n-    }\n-\n-    pub fn write_session_wd_file<P: AsRef<std::path::Path>>(\n-        &self,\n-        path: P,\n-        contents: &str,\n-    ) -> Result<()> {\n-        self.repository.lock()?;\n-        defer! {\n-            self.repository.unlock().expect(\"failed to unlock\");\n-        }\n-\n-        let path = path.as_ref();\n-        self.writer.write_string(\n-            self.repository\n-                .session_wd_path()\n-                .join(path)\n-                .to_str()\n-                .unwrap(),\n-            contents,\n-        )?;\n-\n-        log::info!(\n-            \"{}: wrote session wd file {}\",\n-            self.repository.project_id,\n-            path.display()\n-        );\n-\n-        Ok(())\n-    }\n-\n-    pub fn write_bookmark(&self, bookmark: &bookmarks::Bookmark) -> Result<()> {\n-        self.repository.lock()?;\n-        defer! {\n-            self.repository.unlock().expect(\"failed to unlock\");\n-        }\n-\n-        serde_jsonlines::append_json_lines(\n-            self.repository.session_path().join(\"bookmarks.jsonl\"),\n-            [bookmark],\n-        )?;\n-\n-        log::info!(\n-            \"{}: wrote bookmark {}\",\n-            self.repository.project_id,\n-            bookmark.timestamp_ms\n-        );\n-\n-        Ok(())\n-    }\n-\n-    pub fn write_deltas<P: AsRef<std::path::Path>>(\n-        &self,\n-        path: P,\n-        deltas: &Vec<deltas::Delta>,\n-    ) -> Result<()> {\n-        self.repository.lock()?;\n-        defer! {\n-            self.repository.unlock().expect(\"failed to unlock\");\n-        }\n-\n-        let path = path.as_ref();\n-\n-        let raw_deltas = serde_json::to_string(&deltas)?;\n-\n-        self.writer.write_string(\n-            self.repository.deltas_path().join(path).to_str().unwrap(),\n-            &raw_deltas,\n-        )?;\n-\n-        log::info!(\n-            \"{}: wrote deltas for {}\",\n-            self.repository.project_id,\n-            path.display()\n-        );\n-\n         Ok(())\n     }\n }\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/sessions/writer.rs"
					}
				]
			},
			{
				"id": "writers:src-tauri/src/watcher/handlers/project_file_change.rs",
				"path": "src-tauri/src/watcher/handlers/project_file_change.rs",
				"kind": "file",
				"hunks": [
					{
						"id": "writers:src-tauri/src/watcher/handlers/project_file_change.rs:154",
						"name": "Changes writer implementation for writing deltas and WD files.",
						"diff": "@@ -154,15 +154,13 @@ impl<'listener> Handler<'listener> {\n             return Ok(vec![]);\n         }\n \n-        let writer = sessions::Writer::open(self.gb_repository, &current_session)?;\n-\n         let deltas = text_doc.get_deltas();\n-\n+        let writer = deltas::Writer::new(self.gb_repository)?;\n         writer\n-            .write_deltas(path, &deltas)\n+            .write(path, &deltas)\n             .with_context(|| \"failed to write deltas\")?;\n         writer\n-            .write_session_wd_file(path, &current_file_content)\n+            .write_wd_file(path, &current_file_content)\n             .with_context(|| \"failed to write file\")?;\n \n         Ok(vec![\n",
						"kind": "hunk",
						"modifiedAt": "2023-06-05T08:43:58Z",
						"filePath": "src-tauri/src/watcher/handlers/project_file_change.rs"
					}
				]
			}
		],
		"description": "Writers\nestablish a clear writer api pattern for different types"
	}
]
